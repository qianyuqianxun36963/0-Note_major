<h1>装饰器模式又叫包装器模式（十一）</h1>

<h2>装饰模式（Decorator Pattern）</h2>

<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。</p>

<h2>装饰模式的通用类图</h2>

<p><img alt="" src="https://img-blog.csdn.net/20180109211231203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQwMTE0MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>

<p><br />
在类图中，有四个角色需要说明：</p>

<p>● Component抽象构件<br />
Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，如上面的成绩单。</p>

<p>注意　在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当Component抽象构件。</p>

<p>● ConcreteComponent 具体构件</p>

<p>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。</p>

<p>● Decorator装饰角色</p>

<p>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。</p>

<p>● 具体装饰角色<br />
ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西，上面的例子就是把一个比较平庸的成绩单装饰成家长认可的成绩单。</p>

<p>装饰模式的所有角色都已经解释完毕，我们来看看如何实现，先看抽象构件，</p>

<p>抽象构件</p>

<ol start="1">
	<li>public&nbsp;abstract&nbsp;class&nbsp;Component&nbsp;{&nbsp;&nbsp;</li>
	<li>//抽象的方法&nbsp;&nbsp;</li>
	<li>public&nbsp;abstract&nbsp;void&nbsp;operate();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>具体构件</p>

<ol start="1">
	<li>public&nbsp;class&nbsp;ConcreteComponent&nbsp;extends&nbsp;Component&nbsp;{&nbsp;&nbsp;</li>
	<li>//具体实现&nbsp;&nbsp;</li>
	<li>@Override&nbsp;&nbsp;</li>
	<li>public&nbsp;void&nbsp;operate()&nbsp;{&nbsp;&nbsp;</li>
	<li>System.out.println(&quot;do&nbsp;Something&quot;);&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
	<li>}&nbsp;&nbsp;</li>
</ol>

<p>装饰角色通常是一个抽象类</p>

<p>抽象装饰者</p>

<ol start="1">
	<li>public&nbsp;abstract&nbsp;class&nbsp;Decorator&nbsp;extends&nbsp;Component&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Component&nbsp;component&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过构造函数传递被修饰者&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Decorator(Component&nbsp;_component){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.component&nbsp;=&nbsp;_component;&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//委托给被修饰者执行&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;operate()&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.component.operate();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>当然了，若只有一个装饰类，则可以没有抽象装饰角色，直接实现具体的装饰角色即可。</p>

<p>具体的装饰类</p>

<ol start="1">
	<li>public&nbsp;class&nbsp;ConcreteDecorator1&nbsp;extends&nbsp;Decorator&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//定义被修饰者&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteDecorator1(Component&nbsp;_component){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(_component);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//定义自己的修饰方法&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;method1(){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;method1&nbsp;修饰&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//重写父类的Operation方法&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;operate(){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.method1();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.operate();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>&nbsp;</p>

<ol start="1">
	<li>public&nbsp;class&nbsp;ConcreteDecorator2&nbsp;extends&nbsp;Decorator&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//定义被修饰者&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteDecorator2(Component&nbsp;_component){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(_component);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//定义自己的修饰方法&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;method2(){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;method2修饰&quot;);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//重写父类的Operation方法&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;operate(){&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.operate();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.method2();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<p>注意　原始方法和装饰方法的执行顺序在具体的装饰类是固定的，可以通过方法重载实现多种执行顺序。我们通过Client类来模拟高层模块的耦合关系，看看装饰模式是如何运行的，如代码清单17-14所示。</p>

<p>场景类</p>

<ol start="1">
	<li>public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;component&nbsp;=&nbsp;new&nbsp;ConcreteComponent();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第一次修饰&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;new&nbsp;ConcreteDecorator1(component);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//第二次修饰&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;new&nbsp;ConcreteDecorator2(component);&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//修饰后运行&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component.operate();&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	<li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
</ol>

<h2>装饰模式的优点</h2>

<p>● 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。</p>

<p>● 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。</p>

<p>● 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。</p>

<p>● 装饰者模式可以提供比继承更多的灵活性</p>

<p>● 可以通过一种动态的方式来扩展一个对象的功能，<strong>在运行时</strong>选择不同的装饰器，从而实现不同的行为。</p>

<p>● 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</p>

<p>● 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，<strong>原有代码无须改变，符合&ldquo;开闭原则&rdquo;</strong>。</p>

<h2>装饰模式的缺点</h2>

<p>● 对于装饰模式记住一点就足够了：<strong>多层的装饰是比较复杂的</strong>。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，因此，尽量减少装饰类的数量，以便降低系统的复杂度。</p>

<p>● <strong>会产生很多的小对象</strong>，增加了系统的复杂性</p>

<p>● 这种比继承更加灵活机动的特性，也同时意味着<strong>装饰模式比继承更加易于出错，排错也很困难</strong>，对于多次装饰的对象，<strong>调试时寻找错误可能需要逐级排查，较为烦琐</strong>。</p>

<h2>装饰模式的使用场景</h2>

<p>● 需要扩展一个类的功能，或给一个类增加附加功能。</p>

<p>● 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</p>

<p>● 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</p>

<h2>最佳实践</h2>

<p>装饰模式是对继承的有力补充。你要知道继承不是万能的，继承可以解决实际的问题，但是在项目中你要考虑诸如易维护、易扩展、易复用等，而且在一些情况下你要是用继承就会增加很多子类，而且灵活性非常差，那当然维护也不容易了，也就是说装饰模式可以替代继承，解决我们类膨胀的问题。同时，你还要知道继承是静态地给类增加功能，而装饰模式则是动态地增加功能。装饰模式还有一个非常好的优点：扩展性非常好。通过装饰模式重新封装一个类，而不是通过继承来完成。</p>

<p>&nbsp;</p>

<h2><strong>总结</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</h2>

<p>&nbsp; &nbsp; 1、 组合和委托可以在运行时动态的添加新的行为，而继承是静态的，在系统编译时就已经决定了对象的行为。<br />
&nbsp; &nbsp;&nbsp;<br />
&nbsp; &nbsp; 2、装饰者模式意味着一群装饰者类，这些类用来包装具体组件<br />
&nbsp; &nbsp;&nbsp;<br />
&nbsp; &nbsp; 3、装饰者可以在被装饰者的行为前面或者后面加上自己的行为，甚至可以将被装饰者的行为整个取代掉，从而达到特定的目的。<br />
&nbsp; &nbsp;&nbsp;<br />
&nbsp; &nbsp; 4、可以用多个装饰者包装一个组件。<br />
&nbsp; &nbsp;&nbsp;<br />
&nbsp; &nbsp; 5、装饰者一般对于组件的客户是透明的，除非客户程序依赖于组件的具体类型。<br />
&nbsp; &nbsp;&nbsp;<br />
&nbsp; &nbsp; 6、装饰者会导致设计中出现许多的小对象，如果过度的使用，会让系统变得更加复杂。<br />
&nbsp; &nbsp;&nbsp;<br />
&nbsp; &nbsp; 7、装饰者和被装饰者对象有相同的超类型。</p>
