<h1>Kafka分布式消息系统</h1>

<p><strong>什么是Apache kafka？</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统应用用户的活动数据、请求数据、交互数据、运行维护数据如性能监测、服务器CPU指标这些大量的数据都在无时无刻的产生，Kafka便是有着一套成熟的消息处理方案的消息系统，支持高吞吐量的分布式发布订阅消息模式，它可以处理消费者规模的网站中的所有动作流数据。也是Apache的顶级开源框架。</p>

<h3><strong>应用领域</strong></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已被多家公司用作多类型的数据管道和消息系统，如淘宝、支付宝、百度等；并且一些大数据计算框架如笔者前面介绍的storm、spark都支持与kafka的集成。主要应用场景是kafka作为消息接受系统，将负责接收大量数据，传输给storm进行数据计算处理。</p>

<p><img alt="" src="http://img.blog.csdn.net/20160326114805470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="height:346px; width:758px" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 具体在项目中的应用部署，kafka主要应用在数据计算框架和客户端请求中间，前端程序将消息push到Kafka 服务器集群的某一broker中，通过订阅模式，数据处理框架从Kafka中获取数据进行计算。</p>

<h3><strong>Kafka相关概念</strong></h3>

<p><strong>AMQP协议：</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advanced Message Queuing Protocol，高级消息队列协议提供了消息交互规范，它和kafka或这rabbitMQ、activeMQ的关系就类如JPA规范和hibernate以及多个实现JPA规范的持久层框架一样。</p>

<p><strong>kafka架构：</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Producer：消息生产者，负责发布消息到Kafka&nbsp;broker</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Broker&nbsp;：Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker.<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Consumer：消息消费者，向Kafka&nbsp;broker读取消息。</p>

<p><img alt="" src="http://img.blog.csdn.net/20160326114513073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p><strong>kafka的消息分两个层次：</strong></p>

<p>Topic：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Kafka将消息以topic为单位进行组织。如同生活中我们将消息分类为娱乐消息、体育消息、财经消息，kafka将一种消息类别组织为一个topic，一般系统以不同业务将消息进行topic划分。</p>

<p>Partition：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个topic中的消息数据按照多个分区进行组织，分区是kafka消息队列的最小组织单位。按照先进先出FIFO队列进行消息管理。</p>

<p><img alt="" src="http://img.blog.csdn.net/20160326114535917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<h3><strong>Kafka消息处理流程</strong></h3>

<h3><strong><img alt="" src="http://img.blog.csdn.net/20160326114407463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></strong></h3>

<h1>分布式消息系统：Kafka</h1>

<p>Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。</p>

<p>在大数据系统中，常常会碰到一个问题，整个大数据是由各个子系统组成，数据需要在各个子系统中高性能，低延迟的不停流转。传统的企业消息系统并不是非常适合大规模的数据处理。为了已在同时搞定在线应用（消息）和离线应用（数据文件，日志）Kafka就出现了。Kafka可以起到两个作用：</p>

<ol>
	<li>降低系统组网复杂度。</li>
	<li>降低编程复杂度，各个子系统不在是相互协商接口，各个子系统类似插口插在插座上，Kafka承担高速数据总线的作用。</li>
</ol>

<h3>Kafka主要特点：</h3>

<ol>
	<li>同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。</li>
	<li>可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。</li>
	<li>分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。</li>
	<li>消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。</li>
	<li>支持online和offline的场景。</li>
</ol>

<h3>Kafka的架构：</h3>

<p>Kafka的整体架构非常简单，是显式分布式架构，producer、broker（kafka）和consumer都可以有多个。Producer，consumer实现Kafka注册的接口，数据从producer发送到broker，broker承担一个中间缓存和分发的作用。broker分发注册到系统中的consumer。broker的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。客户端和服务器端的通信，是基于简单，高性能，且与编程语言无关的TCP协议。几个基本概念：</p>

<ol>
	<li>Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。</li>
	<li>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li>
	<li>Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。</li>
	<li>Producers：消息和数据生产者，向Kafka的一个topic发布消息的过程叫做producers。</li>
	<li>Consumers：消息和数据消费者，订阅topics并处理其发布的消息的过程叫做consumers。</li>
	<li>Broker：缓存代理，Kafa集群中的一台或多台服务器统称为broker。</li>
</ol>

<h3>消息发送的流程：</h3>

<ol>
	<li>Producer根据指定的partition方法（round-robin、hash等），将消息发布到指定topic的partition里面</li>
	<li>kafka集群接收到Producer发过来的消息后，将其持久化到硬盘，并保留消息指定时长（可配置），而不关注消息是否被消费。</li>
	<li>Consumer从kafka集群pull数据，并控制获取消息的offset</li>
</ol>

<h3>Kafka的设计：</h3>

<p>1、吞吐量</p>

<p>高吞吐是kafka需要实现的核心目标之一，为此kafka做了以下一些设计：</p>

<ol>
	<li>数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能</li>
	<li>zero-copy：减少IO操作步骤</li>
	<li>数据批量发送</li>
	<li>数据压缩</li>
	<li>Topic划分为多个partition，提高parallelism</li>
</ol>

<p>负载均衡</p>

<ol>
	<li>producer根据用户指定的算法，将消息发送到指定的partition</li>
	<li>存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上</li>
	<li>多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over</li>
	<li>通过zookeeper管理broker与consumer的动态加入与离开</li>
</ol>

<p>拉取系统</p>

<p>由于kafka broker会持久化数据，broker没有内存压力，因此，consumer非常适合采取pull的方式消费数据，具有以下几点好处：</p>

<ol>
	<li>简化kafka设计</li>
	<li>consumer根据消费能力自主控制消息拉取速度</li>
	<li>consumer根据自身情况自主选择消费模式，例如批量，重复消费，从尾端开始消费等</li>
</ol>

<p>可扩展性</p>

<p>当需要增加broker结点时，新增的broker会向zookeeper注册，而producer及consumer会根据注册在zookeeper上的watcher感知这些变化，并及时作出调整。</p>

<p>Kayka的应用场景：</p>

<p>1.消息队列</p>

<p>比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统，如<a href="http://activemq.apache.org/" target="_blank">ActiveMR</a>或<a href="https://www.rabbitmq.com/" target="_blank">RabbitMQ</a>。</p>

<p>2.行为跟踪</p>

<p>Kafka的另一个应用场景是跟踪用户浏览页面、搜索及其他行为，以发布-订阅的模式实时记录到对应的topic里。那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。</p>

<p>3.元信息监控</p>

<p>作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。</p>

<p>4.日志收集</p>

<p>日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或HDFS）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比起以日志为中心的系统比如Scribe或者Flume来说，Kafka提供同样高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。</p>

<p>5.流处理</p>

<p>这个场景可能比较多，也很好理解。保存收集流数据，以提供之后对接的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从RSS数据源中抓取文章的内容，然后将其丢入一个叫做&ldquo;文章&rdquo;的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。<a href="http://storm.incubator.apache.org/" target="_blank">Strom</a>和<a href="http://samza.incubator.apache.org/" target="_blank">Samza</a>是非常著名的实现这种类型数据转换的框架。</p>

<p>6.事件源</p>

<p>事件源是一种应用程序设计的方式，该方式的状态转移被记录为按时间顺序排序的记录序列。Kafka可以存储大量的日志数据，这使得它成为一个对这种方式的应用来说绝佳的后台。比如动态汇总（News feed）。</p>

<p>7.持久性日志（commit log）</p>

<p>Kafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中日志压缩功能为这种用法提供了条件。在这种用法中，Kafka类似于Apache BookKeeper项目。</p>

<h3>Kayka的设计要点：</h3>

<p>1、直接使用linux 文件系统的cache，来高效缓存数据。</p>

<p>2、采用linux Zero-Copy提高发送性能。传统的数据发送需要发送4次上下文切换，采用sendfile系统调用之后，数据直接在内核态交换，系统上下文切换减少为2次。根据测试结果，可以提高60%的数据发送性能。Zero-Copy详细的技术细节可以参考：https://www.ibm.com/developerworks/linux/library/j-zerocopy/</p>

<p>3、数据在磁盘上存取代价为O(1)。kafka以topic来进行消息管理，每个topic包含多个part（ition），每个part对应一个逻辑log，有多个segment组成。每个segment中存储多条消息（见下图），消息id由其逻辑位置决定，即从消息id可直接定位到消息的存储位置，避免id到位置的额外映射。每个part在内存中对应一个index，记录每个segment中的第一条消息偏移。发布者发到某个topic的消息会被均匀的分布到多个part上（随机或根据用户指定的回调函数进行分布），broker收到发布消息往对应part的最后一个segment上添加该消息，当某个segment上的消息条数达到配置值或消息发布时间超过阈值时，segment上的消息会被flush到磁盘，只有flush到磁盘上的消息订阅者才能订阅到，segment达到一定的大小后将不会再往该segment写数据，broker会创建新的segment。</p>

<p>4、显式分布式，即所有的producer、broker和consumer都会有多个，均为分布式的。Producer和broker之间没有负载均衡机制。broker和consumer之间利用zookeeper进行负载均衡。所有broker和consumer都会在zookeeper中进行注册，且zookeeper会保存他们的一些元数据信息。如果某个broker和consumer发生了变化，所有其他的broker和consumer都会得到通知。</p>

<h1>分布式消息中间件 kafka</h1>

<p>一、Kafka发布订阅消息系统基础</p>

<p>&nbsp; &nbsp; &nbsp;Kafka 是分布式发布-订阅消息系统。它最初由 LinkedIn 公司开发，使用 Scala语言编写,之后成为 Apache 顶级项目框架。Kafka 是一个分布式的，可划分的，多订阅者,冗余备份的持久性的服务。</p>

<p>&nbsp; &nbsp; &nbsp;在<a href="http://blog.csdn.net/daybreak1209/article/details/51679482" target="_blank">Kafka生态架构实战</a>中已经介绍了Kafka生态系统，伴随大数据计算，kafka作为重要的数据缓冲者，将flume收集的数据缓冲，提供给storm进行实时计算。同于storm框架，针对实时性、流式计算系统也是kafka的主要应用。它主要用于处理活跃的流式数据。</p>

<p><strong>二、Kafka的特点</strong></p>

<p>1、同时为发布和订阅提供高吞吐量。统计Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）。</p>

<p>2、可持久化操作。将消息持久化到磁盘，因此可用于批量消费，通过将数据持久化到硬盘以及 replication 防止数据丢失。</p>

<p>3、分布式系统，易于向外扩展。所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。</p>

<p>4、kafka每个实例（broker）是无状态的，只管消息的增减，不管谁来消费，消息被处理的状态是由consumer主动从topic分区中pull消息，也就是说消息由谁消费由 consumer 决定，而不是由 server的broker决定。</p>

<p><strong>三、Kafka性能测试 &nbsp;</strong></p>

<p>&nbsp;<img alt="" src="http://img.blog.csdn.net/20160618152549013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p>&nbsp; &nbsp; &nbsp;数据大量堆积导致broker卡死，这里就将使用到topic的分区，分散broker中的日志存储大小。</p>

<p><strong>四、Kafka核心</strong></p>

<p>1、Kafka核心组件</p>

<p>&nbsp; &nbsp; &nbsp;Producer：消息的生产者</p>

<p>&nbsp; &nbsp; &nbsp;Consumer：特指消息的消费者</p>

<p>&nbsp; &nbsp; &nbsp;Consumer Group：消费者组，可以并行消费Topic中partition的消息</p>

<p>&nbsp; &nbsp; &nbsp;Broker：缓存代理，Kafa 集群中的一台或多台服务器统称为 broker。</p>

<p>&nbsp; &nbsp; &nbsp;Topic：特指 Kafka 处理的消息源（feeds of messages）的不同分类。</p>

<p>&nbsp; &nbsp; &nbsp;Partition：Topic 物理上的分组，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。partition 中的每条消息都会被分配一个有序的 id（offset）。&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;Message：消息，是通信的基本单位，每个 producer 可以向一个 topic（主题）发布一些消息。</p>

<p>&nbsp; &nbsp; &nbsp;Producers：消息和数据生产者，向 Kafka 的一个 topic 发布消息的过程</p>

<p>&nbsp; &nbsp; &nbsp;Consumers：消息和数据消费者，订阅 topics 并处理其发布的消息的过程</p>

<p>2、Kafka消息流程</p>

<p><img alt="" src="http://img.blog.csdn.net/20160618151524374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p>（1）消息生产者Producer将消息发送到kafka broker 的Topic中（每个topic中有多个消息）</p>

<p>（2）每个topic中消息增多，topic中的消息进行分区，使得consumer可快速定位消费消息，也可同时消费多个分区中的数据，提高了传输速率。</p>

<p>（3）Consumer Group：消费者组里有多个消费者，每个消费者对应着不同partition分区中的数据处理。例如partition1的数据给Consumer 1，2给2，使得多个分区组成的topic由group中的多个consumer消费，也就是数据内部对相同message的并发处理。</p>

<p>3、核心组件分析</p>

<p>Producers</p>

<p>（1）消息生产者向kafka的一个topic中分布消息的过程kafka称为Producers</p>

<p>（2）变相的负载均衡：把消息发给topic的哪个partition里，实现对消息的均衡分发</p>

<p>（3）批量异步发送：producer和broker 两端（消息的客户端和服务端），不在一台服务器中，如果每产生一条消息就进行发送，建立一次网络连接，势必影响效率。Kafka的消息发送过程采取批量，异步发送。</p>

<p>Broker</p>

<p>（1）支持消息持久化：Broker没有副本备份，但kafka将消息进行持久化操作，以免丢失。当Consumer到kafka的broker中获取数据时，broker不会直接给consumer消费，而是把数据先保存到broker本地日志文件中（具体路径可配），每个Partition都会有一个log文件。另外日志的添加采用追加方式进行持久化，达到一个消息有序持久化效果。写入日志文件：缓存到一定阈值之后，再读写磁盘进行IO操作，提高性能</p>

<p>（2）谁消费了message，由消费者确定和维护这类信息（具体有zookeeper记录维护），broker不保存。</p>

<p>（5）消费时发生故障，kafka可快速定位到故障时没消费的那条数据。&nbsp;consumer如何确定哪些消息是它没有消费的？zk来记录哪条消息消费情况，如何快速的找到没有消费的消息就涉及到kafka的稀疏索引机制。接下来再继续研究。</p>

<p>Messge</p>

<p>消息的3个属性：&nbsp;</p>

<p>（1）Offset &nbsp;偏移量 &nbsp; 消息的唯一标识，通过该标识找到消息。</p>

<p>（2）MessageSize 消息大小</p>

<p>（3）data &nbsp; 消息本身</p>

<p>Partition</p>

<p>分区的目的：</p>

<p>（1）减缓日志文件占用磁盘空间</p>

<p>大量消息，broker都要持久化到文件中，硬盘占用空间增大。分区将消息颗粒细分，每个partition可以存放在不同的硬盘空间中，避免单个broker中的topic文件侵占内存空间</p>

<p>（2）不同的consumer同时处理partition中的数据</p>

<p>Kafka中consumer与partition为&nbsp;1：n的关系，即1个分区仅由1个消费者消费；1个消费者可以同时消费多个不同分区。分区细化消息粒度，消费者同时处理多个分区的越多，达到高效的消息并发处理。</p>
