<h1>深入理解Java虚拟机</h1>

<p><br />
&mdash;&mdash;JVM高级特性与最佳实践<br />
目 录<br />
前言<br />
第2版与第1版的区别<br />
本书面向的读者<br />
如何阅读本书<br />
语言约定<br />
内容特色<br />
参考资料<br />
勘误和支持<br />
致谢</p>

<h2>目录</h2>

<p>第一部分 走近Java<br />
第1章 走近Java<br />
1.1 概述<br />
1.2 Java技术体系<br />
1.3 Java发展史<br />
1.4 Java虚拟机发展史<br />
1.4.1 Sun Classic/Exact VM<br />
1.4.2 Sun HotSpot VM<br />
1.4.3 Sun Mobile-Embedded VM/Meta-Circular VM<br />
1.4.4 BEA JRockit/IBM J9 VM<br />
1.4.5 Azul VM/BEA Liquid VM<br />
1.4.6 Apache Harmony/Google Android Dalvik VM<br />
1.4.7 Microsoft JVM及其他<br />
1.5 展望Java技术的未来<br />
1.5.1 模块化<br />
1.5.2 混合语言<br />
1.5.3 多核并行<br />
1.5.4 进一步丰富语法<br />
1.5.5 64位虚拟机<br />
1.6 实战：自己编译JDK<br />
1.6.1 获取JDK源码<br />
1.6.2 系统需求<br />
1.6.3 构建编译环境<br />
1.6.4 进行编译<br />
1.6.5 在IDE工具中进行源码调试<br />
1.7 本章小结<br />
第二部分 自动内存管理机制<br />
第2章 Java内存区域与内存溢出异常<br />
2.1 概述<br />
2.2 运行时数据区域<br />
2.2.1 程序计数器<br />
2.2.2 Java虚拟机栈<br />
2.2.3 本地方法栈<br />
2.2.4 Java堆<br />
2.2.5 方法区<br />
2.2.6 运行时常量池<br />
2.2.7 直接内存<br />
2.3 HotSpot虚拟机对象探秘<br />
2.3.1 对象的创建<br />
2.3.2 对象的内存布局<br />
2.3.3 对象的访问定位<br />
2.4 实战：OutOfMemoryError异常<br />
2.4.1 Java堆溢出<br />
2.4.2 虚拟机栈和本地方法栈溢出<br />
2.4.3 方法区和运行时常量池溢出<br />
2.4.4 本机直接内存溢出<br />
2.5 本章小结<br />
第3章 垃圾收集器与内存分配策略<br />
3.1 概述<br />
3.2 对象已死吗<br />
3.2.1 引用计数算法<br />
3.2.2 可达性分析算法<br />
3.2.3 再谈引用<br />
3.2.4 生存还是死亡<br />
3.2.5 回收方法区<br />
3.3 垃圾收集算法<br />
3.3.1 标记-清除算法<br />
3.3.2 复制算法<br />
3.3.3 标记-整理算法<br />
3.3.4 分代收集算法<br />
3.4 HotSpot的算法实现<br />
3.4.1 枚举根节点<br />
3.4.2 安全点<br />
3.4.3 安全区域<br />
3.5 垃圾收集器<br />
3.5.1 Serial收集器<br />
3.5.2 ParNew收集器<br />
3.5.3 Parallel Scavenge收集器<br />
3.5.4 Serial Old收集器<br />
3.5.5 Parallel Old收集器<br />
3.5.6 CMS收集器<br />
3.5.7 G1收集器<br />
3.5.8 理解GC日志<br />
3.5.9 垃圾收集器参数总结<br />
3.6 内存分配与回收策略<br />
3.6.1 对象优先在Eden分配<br />
3.6.2 大对象直接进入老年代<br />
3.6.3 长期存活的对象将进入老年代<br />
3.6.4 动态对象年龄判定<br />
3.6.5 空间分配担保<br />
3.7 本章小结<br />
第4章 虚拟机性能监控与故障处理工具<br />
4.1 概述<br />
4.2 JDK的命令行工具<br />
4.2.1 jps：虚拟机进程状况工具<br />
4.2.2 jstat：虚拟机统计信息监视工具<br />
4.2.3 jinfo：Java配置信息工具<br />
4.2.4 jmap：Java内存映像工具<br />
4.2.5 jhat：虚拟机堆转储快照分析工具<br />
4.2.6 jstack：Java堆栈跟踪工具<br />
4.2.7 HSDIS：JIT生成代码反汇编<br />
4.3 JDK的可视化工具<br />
4.3.1 JConsole：Java监视与管理控制台<br />
4.3.2 VisualVM：多合一故障处理工具<br />
4.4 本章小结<br />
第5章 调优案例分析与实战<br />
5.1 概述<br />
5.2 案例分析<br />
5.2.1 高性能硬件上的程序部署策略<br />
5.2.2 集群间同步导致的内存溢出<br />
5.2.3 堆外内存导致的溢出错误<br />
5.2.4 外部命令导致系统缓慢<br />
5.2.5 服务器JVM进程崩溃<br />
5.2.6 不恰当数据结构导致内存占用过大<br />
5.2.7 由Windows虚拟内存导致的长时间停顿<br />
5.3 实战：Eclipse运行速度调优<br />
5.3.1 调优前的程序运行状态<br />
5.3.2 升级JDK 1.6的性能变化及兼容问题<br />
5.3.3 编译时间和类加载时间的优化<br />
5.3.4 调整内存设置控制垃圾收集频率<br />
5.3.5 选择收集器降低延迟<br />
5.4 本章小结<br />
第三部分 虚拟机执行子系统<br />
第6章 类文件结构<br />
6.1 概述<br />
6.2 无关性的基石<br />
6.3 Class类文件的结构<br />
6.3.1 魔数与Class文件的版本<br />
6.3.2 常量池<br />
6.3.3 访问标志<br />
6.3.4 类索引、 父类索引与接口索引集合<br />
6.3.5 字段表集合<br />
6.3.6 方法表集合<br />
6.3.7 属性表集合<br />
6.4 字节码指令简介<br />
6.4.1 字节码与数据类型<br />
6.4.2 加载和存储指令<br />
6.4.3 运算指令<br />
6.4.4 类型转换指令<br />
6.4.5 对象创建与访问指令<br />
6.4.6 操作数栈管理指令<br />
6.4.7 控制转移指令<br />
6.4.8 方法调用和返回指令<br />
6.4.9 异常处理指令<br />
6.4.10 同步指令<br />
6.5 公有设计和私有实现<br />
6.6 Class文件结构的发展<br />
6.7 本章小结<br />
第7章 虚拟机类加载机制<br />
7.1 概述<br />
7.2 类加载的时机<br />
7.3 类加载的过程<br />
7.3.1 加载<br />
7.3.2 验证<br />
7.3.3 准备<br />
7.3.4 解析<br />
7.3.5 初始化<br />
7.4 类加载器<br />
7.4.1 类与类加载器<br />
7.4.2 双亲委派模型<br />
7.4.3 破坏双亲委派模型<br />
7.5 本章小结<br />
第8章 虚拟机字节码执行引擎<br />
8.1 概述<br />
8.2 运行时栈帧结构<br />
8.2.1 局部变量表<br />
8.2.2 操作数栈<br />
8.2.3 动态连接<br />
8.2.4 方法返回地址<br />
8.2.5 附加信息<br />
8.3 方法调用<br />
8.3.1 解析<br />
8.3.2 分派<br />
8.3.3 动态类型语言支持<br />
8.4 基于栈的字节码解释执行引擎<br />
8.4.1 解释执行<br />
8.4.2 基于栈的指令集与基于寄存器的指令集<br />
8.4.3 基于栈的解释器执行过程<br />
8.5 本章小结<br />
第9章 类加载及执行子系统的案例与实战<br />
9.1 概述<br />
9.2 案例分析<br />
9.2.1 Tomcat：正统的类加载器架构<br />
9.2.2 OSGi：灵活的类加载器架构<br />
9.2.3 字节码生成技术与动态代理的实现<br />
9.2.4 Retrotranslator：跨越JDK版本<br />
9.3 实战：自己动手实现远程执行功能<br />
9.3.1 目标<br />
9.3.2 思路<br />
9.3.3 实现<br />
9.3.4 验证<br />
9.4 本章小结<br />
第四部分 程序编译与代码优化<br />
第10章 早期（编译期）优化<br />
10.1 概述<br />
10.2 Javac编译器<br />
10.2.1 Javac的源码与调试<br />
10.2.2 解析与填充符号表<br />
10.2.3 注解处理器<br />
10.2.4 语义分析与字节码生成<br />
10.3 Java语法糖的味道<br />
10.3.1 泛型与类型擦除<br />
10.3.2 自动装箱、 拆箱与遍历循环<br />
10.3.3 条件编译<br />
10.4 实战：插入式注解处理器<br />
10.4.1 实战目标<br />
10.4.2 代码实现<br />
10.4.3 运行与测试<br />
10.4.4 其他应用案例<br />
10.5 本章小结<br />
第11章 晚期（运行期）优化<br />
11.1 概述<br />
11.2 HotSpot虚拟机内的即时编译器<br />
11.2.1 解释器与编译器<br />
11.2.2 编译对象与触发条件<br />
11.2.3 编译过程<br />
11.2.4 查看及分析即时编译结果<br />
11.3 编译优化技术<br />
11.3.1 优化技术概览<br />
11.3.2 公共子表达式消除<br />
11.3.3 数组边界检查消除<br />
11.3.4 方法内联<br />
11.3.5 逃逸分析<br />
11.4 Java与C/C++的编译器对比<br />
11.5 本章小结<br />
第五部分 高效并发<br />
第12章 Java内存模型与线程<br />
12.1 概述<br />
12.2 硬件的效率与一致性<br />
12.3 Java内存模型<br />
12.3.1 主内存与工作内存<br />
12.3.2 内存间交互操作<br />
12.3.3 对于volatile型变量的特殊规则<br />
12.3.4 对于long和double型变量的特殊规则<br />
12.3.5 原子性、 可见性与有序性<br />
12.3.6 先行发生原则<br />
12.4 Java与线程<br />
12.4.1 线程的实现<br />
12.4.2 Java线程调度<br />
12.4.3 状态转换<br />
12.5 本章小结<br />
第13章 线程安全与锁优化<br />
13.1 概述<br />
13.2 线程安全<br />
13.2.1 Java语言中的线程安全<br />
13.2.2 线程安全的实现方法<br />
13.3 锁优化<br />
13.3.1 自旋锁与自适应自旋<br />
13.3.2 锁消除<br />
13.3.3 锁粗化<br />
13.3.4 轻量级锁<br />
13.3.5 偏向锁<br />
13.4 本章小结<br />
附录<br />
附录A 编译Windows版的OpenJDK<br />
A.1 获取JDK源码<br />
A.2 系统需求<br />
A.3 构建编译环境<br />
A.4 准备依赖项<br />
A.5 进行编译<br />
附录B 虚拟机字节码指令表<br />
附录C HotSpot虚拟机主要参数表<br />
C.1 内存管理参数<br />
C.2 即时编译参数<br />
C.3 类型加载参数<br />
C.4 多线程相关参数<br />
C.5 性能参数<br />
C.6 调试参数<br />
附录D 对象查询语言（OQL）简介<br />
D.1 SELECT子句<br />
D.2 FROM子句<br />
D.3 WHERE子句<br />
D.4 属性访问器<br />
D.5 OQL语言的BNF范式<br />
附录E JDK历史版本轨迹</p>

<h2>前言</h2>

<p>Java是目前用户最多、 使用范围最广的软件开发技术之一。 Java的技术体系主要由支撑<br />
Java程序运行的虚拟机、 提供各开发领域接口支持的Java API、 Java编程语言及许多第三方<br />
Java框架（如Spring、 Struts等）构成。 在国内，有关Java API、 Java语言语法及第三方框架的<br />
技术资料和书籍非常丰富，相比之下，有关Java虚拟机的资料却显得异常贫乏。<br />
这种状况在很大程度上是由Java开发技术本身的一个重要优点导致的：在虚拟机层面隐<br />
藏了底层技术的复杂性以及机器与操作系统的差异性。 运行程序的物理机器的情况千差万<br />
别，而Java虚拟机则在千差万别的物理机上建立了统一的运行平台，实现了在任意一台虚拟<br />
机上编译的程序都能在任何一台虚拟机上正常运行。 这一极大优势使得Java应用的开发比传<br />
统C/C++应用的开发更高效和快捷，程序员可以把主要精力集中在具体业务逻辑上，而不是<br />
物理硬件的兼容性上。 在一般情况下，一个程序员只要了解了必要的Java API、 Java语法，<br />
以及学习适当的第三方开发框架，就已经基本能满足日常开发的需要了，虚拟机会在用户不<br />
知不觉中完成对硬件平台的兼容及对内存等资源的管理工作。 因此，了解虚拟机的运作并不<br />
是一般开发人员必须掌握的知识。<br />
然而，凡事都具备两面性。 随着Java技术的不断发展，它被应用于越来越多的领域之<br />
中。 其中一些领域，如电力、 金融、 通信等，对程序的性能、 稳定性和可扩展性方面都有极<br />
高的要求。 程序很可能在10个人同时使用时完全正常，但是在10000个人同时使用时就会缓<br />
慢、 死锁，甚至崩溃。 毫无疑问，要满足10000个人同时使用需要更高性能的物理硬件，但<br />
是在绝大多数情况下，提升硬件效能无法等比例地提升程序的运作性能和并发能力，甚至可<br />
能对程序运作状况完全没有任何改善。 这里面有Java虚拟机的原因：为了达到给所有硬件提<br />
供一致的虚拟平台的目的，牺牲了一些与硬件相关的性能特性。 更重要的是人为原因：如果<br />
开发人员不了解虚拟机一些技术特性的运行原理，就无法写出最适合虚拟机运行和自优化的<br />
代码。<br />
其实，目前商用的高性能Java虚拟机都提供了相当多的优化特性和调节手段，用于满足<br />
应用程序在实际生产环境中对性能和稳定性的要求。 如果只是为了入门学习，让程序在自己<br />
的机器上正常运行，那么这些特性可以说是可有可无的；如果用于生产开发，尤其是企业级<br />
生产开发，就迫切需要开发人员中至少有一部分人对虚拟机的特性及调节方法具有很清晰的<br />
认识，所以在Java开发体系中，对架构师、 系统调优师、 高级程序员等角色的需求一直都非<br />
常大。 学习虚拟机中各种自动运作特性的原理也成为了Java程序员成长道路上必然会接触到<br />
的一课。 本书可以使读者以一种相对轻松的方式学习虚拟机的运作原理，对Java程序员的成<br />
长也有较大的帮助。</p>

<h2>第2版与第1版的区别</h2>

<p>JDK 1.7在2011年7月28日正式发布，相对于2006年发布的JDK 1.6，新版的JDK有了许多<br />
新的特性和改进。 本书的第2版也相应地进行了修改和升级，把讲解的技术平台从JDK 1.6提<br />
升至JDK 1.7。 例如，增加了对JDK 1.7中最新的G1收集器，以及JDK 1.7中JSR-292<br />
InvokeDynamic（对非Java语言的调用支持）的分析讲解等内容。<br />
在第1版出版后，笔者收到了许多热心读者的反馈意见，部分读者提出OpenJDK开源已<br />
久，第1版却很少有直接分析OpenJDK源码的内容，有点&ldquo;视宝山而不见&rdquo;的感觉。 因此，在<br />
本书第2版中，笔者特别加强了对这部分内容的讲解，其中在第1章中就介绍了如何分析、 调<br />
试OpenJDK源码等。 在本书后续章节中，不少关于功能点的讲解都直接使用OpenJDK中的<br />
HotSpot源码或者JIT编译器生成的本地代码作为论据。<br />
如何把Java虚拟机原理中许多理论性很强的知识、 特性应用于实践开发，是本书贯穿始<br />
终的主旨。 由于笔者希望在本书第2版中进一步加强知识的实践性，因此增加了许多对处理<br />
JVM常见问题技能的讲解，包括如何分析GC日志、 如何分析JIT编译器代码优化过程和生成<br />
代码等。 并且，在第1版的基础上，第2版中进一步增加了若干处理JVM问题的实践案例供读<br />
者参考。<br />
另外，本书第2版还修正了第1版中多处错误的、 有歧义的和不完整的描述。 有关勘误信<br />
息，可以参考第1版的勘误页面（http://icyfenix.iteye.com/blog/1119214）。</p>

<h2><br />
本书面向的读者</h2>

<p><br />
（1）使用Java技术体系的中、 高级开发人员<br />
Java虚拟机作为中、 高级开发人员必须修炼的知识，有着较高的学习门槛，本书可作为<br />
学习虚拟机的优秀教材。<br />
（2）系统调优师<br />
系统调优师是近几年才兴起的职业，本书中的大量案例、 代码和调优实战将会对系统调<br />
优师的日常工作有直接的帮助。<br />
（3）系统架构师<br />
保障系统的性能、 并发和伸缩等能力是系统架构师的主要职责之一，而这部分与虚拟机<br />
的运作密不可分，本书可以作为他们制定应用系统底层框架的参考资料。</p>

<h2><br />
如何阅读本书</h2>

<p><br />
本书一共分为五个部分：走近Java、 自动内存管理机制、 虚拟机执行子系统、 程序编译<br />
与代码优化、 高效并发。 各部分基本上是互相独立的，没有必然的前后依赖关系，读者可以<br />
从任何一个感兴趣的专题开始阅读，但是每个部分中的各个章节间有先后顺序。<br />
本书并没有假设读者在Java领域具备很专业的技术水平，因此在保证逻辑准确的前提<br />
下，尽量用通俗的语言和案例讲述虚拟机中与开发的关系最为密切的内容。 当然，学习虚拟<br />
机技术本身就需要读者有一定的基础，且本书的读者定位是中、 高级程序员，因此本书假设<br />
读者自己了解一些常用的开发框架、 Java API和Java语法等基础知识。<br />
笔者希望读者在阅读本书的同时，把本书中的实践内容亲自验证一遍，其中用到的代码<br />
清单可以从华章网站（http://www.hzbook.com）下载。</p>

<h2><br />
语言约定</h2>

<p><br />
本书在语言和技术上有如下约定：<br />
本书中提到HotSpot、 JRockit虚拟机、 WebLogic服务器等产品的所有者时，仍然使用Sun<br />
和BEA公司的名称，实际上，BEA和Sun分别于2008年和2009年被Oracle公司收购，现在已经<br />
不存在这两个商标了，但毫无疑问的是，它们都是在Java领域中做出过卓越贡献的、 值得程<br />
序员纪念的公司。<br />
JDK从1.5版本开始，在官方的正式文档与宣传资料中已经不再使用类似&ldquo;JDK 1.5&rdquo;的名<br />
称，只有程序员内部使用的开发版本号（Developer Version，例如java-version的输出）才继<br />
续沿用1.5、 1.6和1.7的版本号，而公开版本号（Product Version）则改为JDK 5、 JDK 6和JDK<br />
7的命名方式，为了行文一致，本书所有场合统一采用开发版本号的命名方式。<br />
由于版面关系，本书中的许多示例代码都没有遵循最优的代码编写风格，如使用的流没<br />
有关闭流等，请读者在阅读时注意这一点。<br />
如果没有特殊说明，本书中所有讨论都是以Sun JDK 1.7为技术平台的。 不过如果有某个<br />
特性在各个版本间的变化较大，一般都会说明它在各个版本间的差异。</p>

<h2><br />
内容特色</h2>

<p><br />
第一部分 走近Java<br />
本书的第一部分为后文的讲解建立了良好的基础。 尽管了解Java技术的来龙去脉，以及<br />
编译自己的OpenJDK对于读者理解Java虚拟机并不是必需的，但是这些准备过程可以为走近<br />
Java技术和Java虚拟机提供很好的引导。 第一部分只有第1章：<br />
第1章 介绍了Java技术体系的过去、 现在和未来的一些发展趋势，并介绍了如何独立<br />
地编译一个OpenJDK 7。<br />
第二部分 自动内存管理机制<br />
因为程序员把内存控制的权力交给了Java虚拟机，所以可以在编码的时候享受自动内存<br />
管理的诸多优势，不过也正是这个原因，一旦出现内存泄漏和溢出方面的问题，如果不了解<br />
虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 第二部分包括第2<br />
～5章：<br />
第2章 讲解了虚拟机中内存是如何划分的，以及哪部分区域、 什么样的代码和操作可<br />
能导致内存溢出异常，并讲解了各个区域出现内存溢出异常的常见原因。<br />
第3章 分析了垃圾收集的算法和JDK 1.7中提供的几款垃圾收集器的特点及运作原理。<br />
通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。<br />
第4章 介绍了随JDK发布的6个命令行工具与两个可视化的故障处理工具的使用方法。<br />
第5章 与读者分享了几个比较有代表性的实际案例，还准备了一个所有开发人员都<br />
能&ldquo;亲身实战&rdquo;的练习，读者可通过实践来获得故障处理和调优的经验。<br />
第三部分 虚拟机执行子系统<br />
执行子系统是虚拟机中必不可少的组成部分，了解了虚拟机如何执行程序，才能写出更<br />
优秀的代码。 第三部分包括第6～9章：<br />
第6章 讲解了Class文件结构中的各个组成部分，以及每个部分的定义、 数据结构和使<br />
用方法，以实战的方式演示了Class文件的数据是如何存储和访问的。<br />
第7章 介绍了类加载过程的&ldquo;加载&rdquo;、 &ldquo;验证&rdquo;、 &ldquo;准备&rdquo;、 &ldquo;解析&rdquo;和&ldquo;初始化&rdquo;5个阶段中虚<br />
拟机分别执行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。<br />
第8章 分析了虚拟机在执行代码时如何找到正确的方法，如何执行方法内的字节码，<br />
以及执行代码时涉及的内存结构。<br />
第9章 通过4个类加载及执行子系统的案例，分享了使用类加载器和处理字节码的一些<br />
值得欣赏和借鉴的思路，并通过一个实战练习来加深对前面理论知识的理解。<br />
第四部分 程序编译与代码优化<br />
Java程序从源码编译成字节码和从字节码编译成本地机器码的这两个过程，合并起来其<br />
实就等同于一个传统编译器所执行的编译过程。 第四部分包括第10～11章：<br />
第10章 分析了Java语言中泛型、 主动装箱和拆箱、 条件编译等多种语法糖的前因后<br />
果，并通过实战演示了如何使用插入式注解处理器来实现一个检查程序命名规范的编译器插<br />
件。<br />
第11章 讲解了虚拟机的热点探测方法、 HotSpot的即时编译器、 编译触发条件，以及<br />
如何从虚拟机外部观察和分析JIT编译的数据和结果，此外，还讲解了几种常见的编译优化<br />
技术。<br />
第五部分 高效并发<br />
Java语言和虚拟机提供了原生的、 完善的多线程支持，这使得它天生就适合开发多线程<br />
并发的应用程序。 不过我们不能期望系统来完成所有并发相关的处理，了解并发的内幕也是<br />
成为一个高级程序员不可缺少的课程。 第五部分包括第12～13章：<br />
第12章 讲解了虚拟机Java内存模型的结构及操作，以及原子性、 可见性和有序性在<br />
Java内存模型中的体现，介绍了先行发生原则的规则及使用，还了解了线程在Java语言中是<br />
如何实现的。<br />
第13章 介绍了线程安全涉及的概念和分类、 同步实现的方式及虚拟机的底层运作原<br />
理，并且介绍了虚拟机实现高效并发所采取的一系列锁优化措施。</p>

<h2><br />
参考资料</h2>

<p><br />
本书名为&ldquo;深入理解Java虚拟机&rdquo;，但要想深入理解虚拟机，仅凭一本书肯定是远远不够<br />
的，读者可以通过以下信息找到更多关于Java虚拟机方面的资料。 我在写作此书的时候，也<br />
从下面这些参考资料中获得了很大的帮助。<br />
（1）书籍<br />
《 The Java Virtual Machine Specification,Java SE 7 Edition》 [1]<br />
要学习虚拟机，无论如何都必须掌握&ldquo;Java虚拟机规范&rdquo;。 这本书的概念和细节描述与Sun<br />
的早期虚拟机（Sun Classic VM）高度吻合，不过，随着技术的发展，高性能虚拟机真正的<br />
细节实现方式已经渐渐与虚拟机规范所描述的差距越来越大，如果只能选择一本参考书来了<br />
解虚拟机，那我推荐这本书。 此书的Java SE 7版在2011年7月出版发行，这是自1999年发布<br />
的《 Java虚拟机规范（第2版）》 以来的第一次版本更新。 笔者对Java SE 7版的全文进行了<br />
翻译，并与原书一样在网上免费发布了全文PDF[2]。<br />
《 The Java Language Specification,Java SE 7 Edition》 [3]<br />
虽然虚拟机并不是Java语言专有的，但是了解Java语言的各种细节规定对理解虚拟机的<br />
行为也是很有帮助的，它与上一本《 Java虚拟机规范》 都是Sun官方出品的书籍，而且这本<br />
书还是由Java之父James Gosling亲自执笔撰写的。 这本书也与《 Java虚拟机规范》 一样，可<br />
以在官方网站完全免费下载到全文PDF，但暂时没有中文译本，《 Java语言规范（第3版）》<br />
于2005年7月由机械工业出版社引进出版。<br />
《 Oracle JRockit The Definitive Guide》<br />
《 Oracle JRockit权威指南》 ，2010年7月出版，国内也没有（可能是尚未）引进这本<br />
书，它是由JRockit的两位资深开发人员（其中一位还是JRockit Mission Control团队的<br />
TeamLeader）撰写的JRockit虚拟机高级使用指南。 虽然JRockit的用户量可能不如HotSpot多，<br />
但也是目前最流行的三大商业虚拟机之一，并且不同虚拟机中的很多实现思路都是可以对比<br />
参照的。 这本书是了解现代高性能虚拟机很好的参考资料。<br />
《 Inside the Java 2 Virtual Machine,Second Edition》<br />
《 深入Java虚拟机（第2版）》 ，2000年1月出版，2003年由机械工业出版社出版其中文<br />
译本。 在相当长的时间里，这本书是唯一的一本关于Java虚拟机的中文图书。<br />
《 Java Performance》<br />
《 Java Performance》 是&ldquo;The Java&rdquo;系列（许多人都读过该系列中最出名的《 Effective<br />
Java》 ）图书中最新的一本，2011年10月出版，暂时没有中文版。 这本书并非全部都围绕<br />
Java虚拟机（只有第3、 4、 7章直接与Java虚拟机相关），而是从操作系统到基于Java的上层<br />
程序性能度量和调优的全面介绍，其中涉及Java虚拟机的内容具备一定的深度和可实践性。<br />
（2）网站资源<br />
高级语言虚拟机圈子：http://hllvm.group.iteye.com/<br />
里面有一些国内关于虚拟机的讨论，并不只限于JVM，而是涉及对所有的高级语言虚拟<br />
机（High-Level Language Virtual Machine）的讨论，但该网站建立在ITEye上，自然还是以讨<br />
论Java虚拟机为主。 圈主RednaxelaFX（莫枢）的博客（http://rednaxelafx.iteye.com/）是另外<br />
一个非常有价值的虚拟机及编译原理等资料的分享园地。<br />
HotSpot Internals：https://wikis.oracle.com/display/HotSpotInternals/Home<br />
一个关于OpenJDK的Wiki网站，许多文章都由JDK的开发团队编写，更新较慢，但是仍<br />
然有很高的参考价值。<br />
The HotSpot Group：http://openjdk.java.net/groups/hotspot/<br />
HotSpot组群，包含虚拟机开发、 编译器、 垃圾收集和运行时4个邮件组，其中有关于<br />
HotSpot虚拟机的最新讨论。<br />
[1]官方地址：http://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf。<br />
[2]官方地址：http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf。<br />
[3]中文译本地址：http://icyfenix.iteye.com/blog/1256329。</p>

<h2><br />
勘误和支持</h2>

<p><br />
在本书交稿的时候，我并不像想象中的那样兴奋或放松，写作之时那种&ldquo;战战兢兢、 如<br />
履薄冰&rdquo;的感觉依然萦绕在心头。 在每一章、 每一节落笔之时，我都在考虑如何才能把各个<br />
知识点更有条理地讲述出来，同时也在担心会不会由于自己理解有偏差而误导了读者。 由于<br />
写作水平和写作时间所限，书中难免存在不妥之处，所以特地开通了一个读者邮箱<br />
（understandingjvm@gmail.com）与大家交流，大家如有任何意见或建议欢迎与我联系。 相信<br />
写书与写程序一样，作品一定都是不完美的，因为不完美，我们才有不断追求完美的动力。<br />
本书第2版的勘误，将会在作者的博客（http://icyfenix.iteye.com/）中发布。 欢迎读者在<br />
博客上留言。</p>

<h2><br />
致谢</h2>

<p><br />
首先要感谢我的家人，在本书写作期间全靠他们对我的悉心照顾，才让我能够全身心地<br />
投入到写作之中，而无后顾之忧。<br />
同时要感谢我的工作单位远光软件，公司为我提供了宝贵的工作、 学习和实践的环境，<br />
书中的许多知识点都来自于工作中的实践；也感谢与我一起工作的同事们，非常荣幸能与你<br />
们一起在这个富有激情的团队中共同奋斗。<br />
还要感谢Oracle公司虚拟机团队的莫枢，在百忙之中抽空审阅了本书，提出了许多宝贵<br />
的建议和意见。<br />
最后，感谢机械工业出版社华章公司的编辑，本书能够顺利出版离不开他们的敬业精神<br />
和一丝不苟的工作态度。<br />
周志明</p>

<h2><br />
第一部分 走近Java</h2>

<h3><br />
第1章 走近Java</h3>

<p><br />
世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求<br />
完美的过程。<br />
1.1 概述<br />
Java不仅仅是一门编程语言，还是一个由一系列计算机软件和规范形成的技术体系，这<br />
个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系<br />
统、 移动终端、 企业服务器、 大型机等各种场合，如图1-1所示。 时至今日，Java技术体系已<br />
经吸引了900多万软件开发者，这是全球最大的软件开发团队。 使用Java的设备多达几十亿<br />
台，其中包括11亿多台个人计算机、 30亿部移动电话及其他手持设备、 数量众多的智能卡，<br />
以及大量机顶盒、 导航系统和其他设备[1]。<br />
图 1-1 Java技术的广泛应用<br />
Java能获得如此广泛的认可，除了它拥有一门结构严谨、 面向对象的编程语言之外，还<br />
有许多不可忽视的优点：它摆脱了硬件平台的束缚，实现了&ldquo;一次编写，到处运行&rdquo;的理想；<br />
它提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问<br />
题；它实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而<br />
获得更高的性能；它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三<br />
方类库来帮助它实现各种各样的功能&hellip;&hellip;Java所带来的这些好处使程序的开发效率得到了很<br />
大的提升。 作为一名Java程序员，在编写程序时除了尽情发挥Java的各种优势外，还应该去<br />
了解和思考一下Java技术体系中这些技术特性是如何实现的。 认识这些技术运作的本质，是<br />
自己思考&ldquo;程序这样写好不好&rdquo;的基础和前提。 当我们在使用一种技术时，如果不再依赖书本<br />
和他人就能得到这些问题的答案，那才算上升到了&ldquo;不惑&rdquo;的境界。<br />
本书将与读者一起分析Java技术中最重要的那些特性的实现原理。 在本章中，我们将重<br />
点介绍Java技术体系内容以及Java的历史、 现在和未来的发展趋势。<br />
[1]这些数据是Java的广告词，它们来源于：http://www.java.com/zh_CN/about/。<br />
1.2 Java技术体系<br />
从广义上讲，Clojure、 JRuby、 Groovy等运行于Java虚拟机上的语言及其相关的程序都<br />
属于Java技术体系中的一员。 如果仅从传统意义上来看，Sun官方所定义的Java技术体系包括<br />
以下几个组成部分：<br />
Java程序设计语言<br />
各种硬件平台上的Java虚拟机<br />
Class文件格式<br />
Java API类库<br />
来自商业机构和开源社区的第三方Java类库<br />
我们可以把Java程序设计语言、 Java虚拟机、 Java API类库这三部分统称为JDK（Java<br />
Development Kit），JDK是用于支持Java程序开发的最小环境，在后面的内容中，为了讲解<br />
方便，有一些地方会以JDK来代替整个Java技术体系。 另外，可以把Java API类库中的Java<br />
SE API子集[1]和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java<br />
程序运行的标准环境。 图1-2展示了Java技术体系所包含的内容，以及JDK和JRE所涵盖的范<br />
围。<br />
图 1-2 Java技术体系所包含的内容[2]<br />
以上是根据各个组成部分的功能来进行划分的，如果按照技术所服务的领域来划分，或<br />
者说按照Java技术关注的重点业务领域来划分，Java技术体系可以分为4个平台，分别为：<br />
Java Card：支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。<br />
Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、 PDA）上的平台，对<br />
Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。<br />
Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java<br />
平台，提供了完整的Java核心API，这个版本以前称为J2SE。<br />
Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、 CRM应用）的<br />
Java平台，除了提供Java SE API外，还对其做了大量的扩充[3]并提供了相关的部署支持，这<br />
个版本以前称为J2EE。<br />
[1]JDK 1.7的Java SE API范围：http://download.oracle.com/javase/7/docs/api/。<br />
[2]图片来源：http://download.oracle.com/javase/7/docs/。<br />
[3]这些扩展一般以javax.*作为包名，而以java.*为包名的包都是Java SE API的核心包，但由<br />
于历史原因，一部分曾经是扩展包的API后来进入了核心包，因此核心包中也包含了不少<br />
javax.*的包名。<br />
1.3 Java发展史<br />
从第一个Java版本诞生到现在已经有18年的时间了。 沧海桑田一瞬间，转眼18年过去<br />
了，在图1-3所展示的时间线中，我们看到JDK已经发展到了1.7版。 在这18年里还诞生了无<br />
数和Java相关的产品、 技术和标准。 现在让我们走入时间隧道，从孕育Java语言的时代开<br />
始，再来回顾一下Java的发展轨迹和历史变迁。<br />
图 1-3 Java技术发展的时间线<br />
1991年4月，由James Gosling博士领导的绿色计划（Green Project）开始启动，此计划的<br />
目的是开发一种能够在各种消费性电子产品（如机顶盒、 冰箱、 收音机等）上运行的程序架<br />
构。 这个计划的产品就是Java语言的前身：Oak（橡树）。 Oak当时在消费品市场上并不算成<br />
功，但随着1995年互联网潮流的兴起，Oak迅速找到了最适合自己发展的市场定位并蜕变成<br />
为Java语言。<br />
1995年5月23日，Oak语言改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。<br />
Java语言第一次提出了&ldquo;Write Once,Run Anywhere&rdquo;的口号。<br />
1996年1月23日，JDK 1.0发布，Java语言有了第一个正式版本的运行环境。 JDK 1.0提供<br />
了一个纯解释执行的Java虚拟机实现（Sun Classic VM）。 JDK 1.0版本的代表技术包括：<br />
Java虚拟机、 Applet、 AWT等。<br />
1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入Java技术。 同年9月，<br />
已有大约8.3万个网页应用了Java技术来制作。 在1996年5月底，Sun公司于美国旧金山举行了<br />
首届JavaOne大会，从此JavaOne成为全世界数百万Java语言开发者每年一度的技术盛会。<br />
1997年2月19日，Sun公司发布了JDK 1.1，Java技术的一些最基础的支撑点（如JDBC<br />
等）都是在JDK 1.1版本中发布的，JDK 1.1版的技术代表有：JAR文件格式、 JDBC、<br />
JavaBeans、 RMI。 Java语法也有了一定的发展，如内部类（Inner Class）和反射<br />
（Reflection）都是在这个时候出现的。<br />
直到1999年4月8日，JDK 1.1一共发布了1.1.0～1.1.8九个版本。 从1.1.4之后，每个JDK版<br />
本都有一个自己的名字（工程代号），分别为：JDK 1.1.4-Sparkler（宝石）、 JDK 1.1.5-<br />
Pumpkin（南瓜）、 JDK 1.1.6-Abigail（阿比盖尔，女子名）、 JDK 1.1.7-Brutus（布鲁图，古<br />
罗马政治家和将军）和JDK 1.1.8-Chelsea（切尔西，城市名）。<br />
1998年12月4日，JDK迎来了一个里程碑式的版本JDK 1.2，工程代号为Playground（竞技<br />
场），Sun在这个版本中把Java技术体系拆分为3个方向，分别是面向桌面应用开发的<br />
J2SE（Java 2 Platform,Standard Edition）、 面向企业级开发的J2EE（Java 2 Platform,Enterprise<br />
Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform,Micro Edition）。 在这个版本<br />
中出现的代表性技术非常多，如EJB、 Java Plug-in、 Java IDL、 Swing等，并且这个版本中<br />
Java虚拟机第一次内置了JIT（Just In Time）编译器（JDK 1.2中曾并存过3个虚拟机，Classic<br />
VM、 HotSpot VM和Exact VM，其中Exact VM只在Solaris平台出现过；后面两个虚拟机都是<br />
内置JIT编译器的，而之前版本所带的Classic VM只能以外挂的形式使用JIT编译器）。 在语<br />
言和API级别上，Java添加了strictfp关键字与现在Java编码之中极为常用的一系列Collections<br />
集合类。 在1999年3月和7月，分别有JDK 1.2.1和JDK 1.2.2两个小版本发布。<br />
1999年4月27日，HotSpot虚拟机发布，HotSpot最初由一家名为&ldquo;Longview<br />
Technologies&rdquo;的小公司开发，因为HotSpot的优异表现，这家公司在1997年被Sun公司收购<br />
了。 HotSpot虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK 1.3及之后所<br />
有版本的Sun JDK的默认虚拟机。<br />
2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布，JDK 1.3相对于JDK 1.2<br />
的改进主要表现在一些类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始<br />
被作为一项平台级服务提供（以前JNDI仅仅是一项扩展），使用CORBA IIOP来实现RMI的<br />
通信协议，等等。 这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且<br />
新添加了JavaSound类库。 JDK 1.3有1个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），<br />
于2001年5月17日发布。<br />
自从JDK 1.3开始，Sun维持了一个习惯：大约每隔两年发布一个JDK的主版本，以动物<br />
命名，期间发布的各个修正版本则以昆虫作为工程名称。<br />
2002年2月13日，JDK 1.4发布，工程代号为Merlin（灰背隼）。 JDK 1.4是Java真正走向<br />
成熟的一个版本，Compaq、 Fujitsu、 SAS、 Symbian、 IBM等著名公司都有参与甚至实现自己<br />
独立的JDK 1.4。 哪怕是在十多年后的今天，仍然有许多主流应用（Spring、 Hibernate、 Struts<br />
等）能直接运行在JDK 1.4之上，或者继续发布能运行在JDK 1.4上的版本。 JDK 1.4同样发布<br />
了很多新的技术特性，如正则表达式、 异常链、 NIO、 日志类、 XML解析器和XSLT转换器<br />
等。 JDK 1.4有两个后续修正版：2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的<br />
JDK 1.4.1与2003年6月26日发布的工程代号为Mantis（螳螂）的JDK 1.4.2。<br />
2002年前后还发生了一件与Java没有直接关系，但事实上对Java的发展进程影响很大的<br />
事件，那就是微软公司的.NET Framework发布了。 这个无论是技术实现上还是目标用户上都<br />
与Java有很多相近之处的技术平台给Java带来了很多讨论、 比较和竞争，.NET平台和Java平<br />
台之间声势浩大的孰优孰劣的论战到目前为止都在继续。<br />
2004年9月30日，JDK 1.5[1]发布，工程代号Tiger（老虎）。 从JDK 1.2以来，Java在语法<br />
层面上的变换一直很小，而JDK 1.5在Java语法易用性上做出了非常大的改进。 例如，自动装<br />
箱、 泛型、 动态注解、 枚举、 可变长参数、 遍历循环（foreach循环）等语法特性都是在JDK<br />
1.5中加入的。 在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory<br />
Model,JMM）、 提供了java.util.concurrent并发包等。 另外，JDK 1.5是官方声明可以支持<br />
Windows 9x平台的最后一个JDK版本。<br />
2006年12月11日，JDK 1.6发布，工程代号Mustang（野马）。 在这个版本中，Sun终结了<br />
从JDK 1.2开始已经有8年历史的J2EE、 J2SE、 J2ME的命名方式，启用Java SE 6、 Java EE<br />
6、 Java ME 6的命名方式。 JDK 1.6的改进包括：提供动态语言支持（通过内置Mozilla<br />
JavaScript Rhino引擎实现）、 提供编译API和微型HTTP服务器API等。 同时，这个版本对Java<br />
虚拟机内部做了大量改进，包括锁与同步、 垃圾收集、 类加载等方面的算法都有相当多的改<br />
动。<br />
在2006年11月13日的JavaOne大会上，Sun公司宣布最终会将Java开源，并在随后的一年<br />
多时间内，陆续将JDK的各个部分在GPL v2（GNU General Public License v2）协议下公开了<br />
源码，并建立了OpenJDK组织对这些源码进行独立管理。 除了极少量的产权代码<br />
（Encumbered Code，这部分代码大多是Sun本身也无权限进行开源处理的）外，OpenJDK几<br />
乎包括了Sun JDK的全部代码，OpenJDK的质量主管曾经表示，在JDK 1.7中，Sun JDK和<br />
OpenJDK除了代码文件头的版权注释之外，代码基本上完全一样，所以OpenJDK 7与Sun JDK<br />
1.7本质上就是同一套代码库开发的产品。<br />
JDK 1.6发布以后，由于代码复杂性的增加、 JDK开源、 开发JavaFX、 经济危机及Sun收<br />
购案等原因，Sun在JDK发展以外的事情上耗费了很多资源，JDK的更新没有再维持两年发布<br />
一个主版本的发展速度。 JDK 1.6到目前为止一共发布了37个Update版本，最新的版本为Java<br />
SE 6 Update 37，于2012年10月16日发布。<br />
2009年2月19日，工程代号为Dolphin（海豚）的JDK 1.7完成了其第一个里程碑版本。 根<br />
据JDK 1.7的功能规划，一共设置了10个里程碑。 最后一个里程碑版本原计划于2010年9月9<br />
日结束，但由于各种原因，JDK 1.7最终无法按计划完成。<br />
从JDK 1.7最开始的功能规划来看，它本应是一个包含许多重要改进的JDK版本，其中的<br />
Lambda项目（Lambda表达式、 函数式编程）、 Jigsaw项目（虚拟机模块化支持）、 动态语言<br />
支持、 GarbageFirst收集器和Coin项目（语言细节进化）等子项目对于Java业界都会产生深远<br />
的影响。 在JDK 1.7开发期间，Sun公司由于相继在技术竞争和商业竞争中都陷入泥潭，公司<br />
的股票市值跌至仅有高峰时期的3%，已无力推动JDK 1.7的研发工作按正常计划进行。 为了<br />
尽快结束JDK 1.7长期&ldquo;跳票&rdquo;的问题，Oracle公司收购Sun公司后不久便宣布将实行&ldquo;B计划&rdquo;，<br />
大幅裁剪了JDK 1.7预定目标，以便保证JDK 1.7的正式版能够于2011年7月28日准时发布。 &ldquo;B<br />
计划&rdquo;把不能按时完成的Lambda项目、 Jigsaw项目和Coin项目的部分改进延迟到JDK 1.8之<br />
中。 最终，JDK 1.7的主要改进包括：提供新的G1收集器（G1在发布时依然处于Experimental<br />
状态，直至2012年4月的Update 4中才正式&ldquo;转正&rdquo;）、 加强对非Java语言的调用支持（JSR-<br />
292，这项特性到目前为止依然没有完全实现定型）、 升级类加载架构等。<br />
到目前为止，JDK 1.7已经发布了9个Update版本，最新的Java SE 7 Update 9于2012年10<br />
月16日发布。 从Java SE 7 Update 4起，Oracle开始支持Mac OS X操作系统，并在Update 6中达<br />
到完全支持的程度，同时，在Update 6中还对ARM指令集架构提供了支持。 至此，官方提供<br />
的JDK可以运行于Windows（不含Windows 9x）、 Linux、 Solaris和Mac OS平台上，支持<br />
ARM、 x86、 x64和Sparc指令集架构类型。<br />
2009年4月20日，Oracle公司宣布正式以74亿美元的价格收购Sun公司，Java商标从此正<br />
式归Oracle所有（Java语言本身并不属于哪间公司所有，它由JCP组织进行管理，尽管JCP主<br />
要是由Sun公司或者说Oracle公司所领导的）。 由于此前Oracle公司已经收购了另外一家大型<br />
的中间件企业BEA公司，在完成对Sun公司的收购之后，Oracle公司分别从BEA和Sun中取得<br />
了目前三大商业虚拟机的其中两个：JRockit和HotSpot,Oracle公司宣布在未来1～2年的时间<br />
内，将把这两个优秀的虚拟机互相取长补短，最终合二为一[2]。 可以预见在不久的将<br />
来，Java虚拟机技术将会产生相当巨大的变化。<br />
根据Oracle官方提供的信息，JDK 1.8的第一个正式版本将于2013年9月发布，JDK 1.8将<br />
会提供在JDK 1.7中规划过，但最终未能在JDK 1.7中发布的特性，即Lambda表达式、<br />
Jigsaw（很不幸，随后Oracle公司又宣布Jigsaw在JDK 1.8中依然无法完成，需要延至JDK<br />
1.9）和JDK 1.7中未实现的一部分Coin等。<br />
在2011年的JavaOne大会上，Oracle公司还提到了JDK 1.9的长远规划，希望未来的Java虚<br />
拟机能够管理数以GB计的Java堆，能够更高效地与本地代码集成，并且令Java虚拟机运行时<br />
尽可能少人工干预，能够自动调节。<br />
[1]JDK从1.5版本开始，官方在正式文档与宣传上已经不再使用类似JDK 1.5的命名，只有在<br />
程序员内部使用的开发版本号（Developer Version，例如java-version的输出）中才继续沿用<br />
1.5、 1.6、 1.7的版本号，而公开版本号（Product Version）则改为JDK 5、 JDK 6、 JDK 7的命<br />
名方式，本书为了行文一致，所有场合统一采用开发版本号的命名方式。<br />
[2]&ldquo;HotRockit&rdquo;项目的相关介绍：http://hirt.se/presentations/WhatToExpect.ppt。<br />
1.4 Java虚拟机发展史<br />
上一节我们从整个Java技术的角度观察了Java技术的发展，许多Java程序员都会潜意识<br />
地把它与Sun公司的HotSpot虚拟机等同看待，也许还有一些程序员会注意到BEA JRockit和<br />
IBM J9，但对JVM的认识不仅仅只有这些。<br />
从1996年初Sun公司发布的JDK 1.0中所包含的Sun Classic VM到今天，曾经涌现、 湮灭过<br />
许多或经典或优秀或有特色的虚拟机实现，在这一节中，我们先暂且把代码与技术放下，一<br />
起来回顾一下Java虚拟机家族的发展轨迹和历史变迁。<br />
1.4.1 Sun Classic/Exact VM<br />
以今天的视角来看，Sun Classic VM的技术可能很原始，这款虚拟机的使命也早已终<br />
结。 但仅凭它&ldquo;世界上第一款商用Java虚拟机&rdquo;的头衔，就足够有让历史记住它的理由。<br />
1996年1月23日，Sun公司发布JDK 1.0，Java语言首次拥有了商用的正式运行环境，这个<br />
JDK中所带的虚拟机就是Classic VM。 这款虚拟机只能使用纯解释器方式来执行Java代码，<br />
如果要使用JIT编译器，就必须进行外挂。 但是假如外挂了JIT编译器，JIT编译器就完全接管<br />
了虚拟机的执行系统，解释器便不再工作了。 用户在这款虚拟机上执行java-version命令，将<br />
会看到类似下面这行输出：<br />
java version&quot;1.2.2&quot;<br />
Classic VM（build JDK-1.2.2-001，green threads,sunwjit）<br />
其中的&ldquo;sunwjit&rdquo;就是Sun提供的外挂编译器，其他类似的外挂编译器还有Symantec JIT和<br />
shuJIT等。 由于解释器和编译器不能配合工作，这就意味着如果要使用编译器执行，编译器<br />
就不得不对每一个方法、 每一行代码都进行编译，而无论它们执行的频率是否具有编译的价<br />
值。 基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这<br />
个阶段的虚拟机即使用了JIT编译器输出本地代码，执行效率也和传统的C/C++程序有很大差<br />
距，&ldquo;Java语言很慢&rdquo;的形象就是在这时候开始在用户心中树立起来的。<br />
Sun的虚拟机团队努力去解决Classic VM所面临的各种问题，提升运行效率。 在JDK 1.2<br />
时，曾在Solaris平台上发布过一款名为Exact VM的虚拟机，它的执行系统已经具备现代高性<br />
能虚拟机的雏形：如两级即时编译器、 编译器与解释器混合工作模式等。 Exact VM因它使用<br />
准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory<br />
Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。 譬如内存<br />
中有一个32位的整数123456，它到底是一个reference类型指向123456的内存地址还是一个数<br />
值为123456的整数，虚拟机将有能力分辨出来，这样才能在GC（垃圾收集）的时候准确判<br />
断堆上的数据是否还可能被使用。 由于使用了准确式内存管理，Exact VM可以抛弃以前<br />
Classic VM基于handler的对象查找方式（原因是进行GC后对象将可能会被移动位置，如果将<br />
地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是reference的前提<br />
下，虚拟机是不敢把内存中所有为123456的值改成654321的，所以要使用句柄来保持<br />
reference值的稳定），这样每次定位对象都少了一次间接查找的开销，提升执行性能。<br />
虽然Exact VM的技术相对Classic VM来说先进了许多，但是在商业应用上只存在了很短<br />
暂的时间就被更为优秀的HotSpot VM所取代，甚至还没有来得及发布Windows和Linux平台下<br />
的商用版本。 而Classic VM的生命周期则相对长了许多，它在JDK 1.2之前是Sun JDK中唯一<br />
的虚拟机，在JDK 1.2时，它与HotSpot VM并存，但默认使用的是Classic VM（用户可用javahotspot参数切换至HotSpot VM），而在JDK 1.3时，HotSpot VM成为默认虚拟机，但Classic<br />
VM仍作为虚拟机的&ldquo;备用选择&rdquo;发布（使用java-classic参数切换），直到JDK 1.4的时<br />
候，Classic VM才完全退出商用虚拟机的历史舞台，与Exact VM一起进入了Sun Labs Research<br />
VM之中。<br />
1.4.2 Sun HotSpot VM<br />
提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟<br />
机，也是目前使用范围最广的Java虚拟机。 但不一定所有人都知道的是，这个目前看起<br />
来&ldquo;血统纯正&rdquo;的虚拟机在最初并非由Sun公司开发，而是由一家名为&ldquo;Longview<br />
Technologies&rdquo;的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于<br />
Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现&ldquo;达到C语言<br />
50%以上的执行效率&rdquo;的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许<br />
多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot<br />
VM。<br />
HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管<br />
理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术<br />
（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式<br />
GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。 为了Exact VM和HotSpot VM哪个<br />
成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上<br />
的胜利），HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代<br />
码，然后通知JIT编译器以方法为单位进行编译。 如果一个方法被频繁调用，或方法中有效<br />
循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。 通过编译器与解释器<br />
恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待<br />
本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码<br />
优化技术，输出质量更高的本地代码。<br />
在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将<br />
JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上<br />
建立了OpenJDK。 这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项<br />
目的共同虚拟机。<br />
在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有<br />
了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约<br />
应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。 整合的方式大致<br />
上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与<br />
MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。<br />
1.4.3 Sun Mobile-Embedded VM/Meta-Circular VM<br />
Sun公司所研发的虚拟机可不仅有前面介绍的服务器、 桌面领域的商用虚拟机，除此之<br />
外，Sun公司面对移动和嵌入式市场，也发布过虚拟机产品，另外还有一类虚拟机，在设计<br />
之初就没抱有商用的目的，仅仅是用于研究、 验证某种技术和观点，又或者是作为一些规范<br />
的标准实现。 这些虚拟机对于大部分不从事相关领域开发的Java程序员来说可能比较陌生。<br />
Sun公司发布的其他Java虚拟机有：<br />
（1）KVM<br />
KVM中的K是&ldquo;Kilobyte&rdquo;的意思，它强调简单、 轻量、 高度可移植，但是运行速度比较<br />
慢。 在Android、 iOS等智能手机操作系统出现前曾经在手机平台上得到非常广泛的应用。<br />
（2）CDC/CLDC HotSpot Implementation<br />
CDC/CLDC全称是Connected（Limited）Device Configuration，在JSR-139/JSR-218规范中<br />
进行定义，它希望在手机、 电子书、 PDA等设备上建立统一的Java编程接口，而CDC-HI VM<br />
和CLDC-HI VM则是它们的一组参考实现。 CDC/CLDC是整个Java ME的重要支柱，但从目前<br />
Android和iOS二分天下的移动数字设备市场看来，在这个领域中，Sun的虚拟机所面临的局<br />
面远不如服务器和桌面领域乐观。<br />
（3）Squawk VM<br />
Squawk VM由Sun公司开发，运行于Sun SPOT（Sun Small Programmable Object<br />
Technology，一种手持的WiFi设备），也曾经运用于Java Card。 这是一个Java代码比重很高<br />
的嵌入式虚拟机实现，其中诸如类加载器、 字节码验证器、 垃圾收集器、 解释器、 编译器和<br />
线程调度都是Java语言本身完成的，仅仅靠C语言来编写设备I/O和必要的本地代码。<br />
（4）JavaInJava<br />
JavaInJava是Sun公司于1997年～1998年间研发的一个实验室性质的虚拟机，从名字就可<br />
以看出，它试图以Java语言来实现Java语言本身的运行环境，既所谓的&ldquo;元循环&rdquo;（MetaCircular，是指使用语言自身来实现其运行环境）。 它必须运行在另外一个宿主虚拟机之<br />
上，内部没有JIT编译器，代码只能以解释模式执行。 在20世纪末主流Java虚拟机都未能很好<br />
解决性能问题的时代，开发这种项目，其执行速度可想而知。<br />
（5）Maxine VM<br />
Maxine VM和上面的JavaInJava非常相似，它也是一个几乎全部以Java代码实现（只有用<br />
于启动JVM的加载器使用C语言编写）的元循环Java虚拟机。 这个项目于2005年开始，到现<br />
在仍然在发展之中，比起JavaInJava,Maxine VM就显得&ldquo;靠谱&rdquo;很多，它有先进的JIT编译器和<br />
垃圾收集器（但没有解释器），可在宿主模式或独立模式下执行，其执行效率已经接近了<br />
HotSpot Client VM的水平。<br />
1.4.4 BEA JRockit/IBM J9 VM<br />
前面介绍了Sun公司的各种虚拟机，除了Sun公司以外，其他组织、 公司也研发过不少虚<br />
拟机实现，其中规模最大、 最著名的就是BEA和IBM公司了。<br />
JRockit VM曾经号称&ldquo;世界上速度最快的Java虚拟机&rdquo;（广告词，貌似J9 VM也这样说<br />
过），它是BEA公司在2002年从Appeal Virtual Machines公司收购的虚拟机。 BEA公司将其发<br />
展为一款专门为服务器硬件和服务器端应用场景高度优化的虚拟机，由于专注于服务器端应<br />
用，它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时<br />
编译器编译后执行。 除此之外，JRockit的垃圾收集器和MissionControl服务套件等部分的实<br />
现，在众多Java虚拟机中也一直处于领先水平。<br />
IBM J9 VM并不是IBM公司唯一的Java虚拟机，不过是目前其主力发展的Java虚拟机。<br />
IBM J9 VM原本是内部开发代号，正式名称是&ldquo;IBM Technology for Java Virtual Machine&rdquo;，简<br />
称IT4J，只是这个名字太拗口了一点，普及程度不如J9。 J9 VM最初是由IBM Ottawa实验室<br />
一个名为SmallTalk的虚拟机扩展而来的，当时这个虚拟机有一个bug是由8k值定义错误引起<br />
的，工程师花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就称为K8了，<br />
后来扩展出支持Java的虚拟机就被称为J9了。 与BEA JRockit专注于服务器端应用不同，IBM<br />
J9的市场定位与Sun HotSpot比较接近，它是一款设计上从服务器端到桌面应用再到嵌入式都<br />
全面考虑的多用途虚拟机，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主<br />
要市场是和IBM产品（如IBM WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署Java<br />
应用。<br />
1.4.5 Azul VM/BEA Liquid VM<br />
我们平时所提及的&ldquo;高性能Java虚拟机&rdquo;一般是指HotSpot、 JRockit、 J9这类在通用平台上<br />
运行的商用虚拟机，但其实Azul VM和BEA Liquid VM这类特定硬件平台专有的虚拟机才<br />
是&ldquo;高性能&rdquo;的武器。<br />
Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的<br />
专有硬件Vega系统上的Java虚拟机，每个Azul VM实例都可以管理至少数十个CPU和数百GB<br />
内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、 为专有硬件<br />
优化的线程调度等优秀特性。 在2010年，Azul Systems公司开始从硬件转向软件，发布了自<br />
己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。<br />
Liquid VM即是现在的JRockit VE（Virtual Edition），它是BEA公司开发的，可以直接运<br />
行在自家Hypervisor系统上的JRockit VM的虚拟化版本，Liquid VM不需要操作系统的支持，<br />
或者说它自己本身实现了一个专用操作系统的必要功能，如文件系统、 网络支持等。 由虚拟<br />
机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核<br />
态/用户态的切换等，这样可以最大限度地发挥硬件的能力，提升Java程序的执行性能。<br />
1.4.6 Apache Harmony/Google Android Dalvik VM<br />
这节介绍的Harmony VM和Dalvik VM只能称做&ldquo;虚拟机&rdquo;，而不能称做&ldquo;Java虚拟机&rdquo;，但<br />
是这两款虚拟机（以及所代表的技术体系）对最近几年的Java世界产生了非常大的影响和挑<br />
战，甚至有些悲观的评论家认为成熟的Java生态系统有崩溃的可能。<br />
Apache Harmony是一个Apache软件基金会旗下以Apache License协议开源的实际兼容于<br />
JDK 1.5和JDK 1.6的Java程序运行平台，这个介绍相当拗口。 它包含自己的虚拟机和Java库，<br />
用户可以在上面运行Eclipse、 Tomcat、 Maven等常见的Java程序，但是它没有通过TCK认<br />
证，所以我们不得不用那么一长串拗口的语言来介绍它，而不能用一句&ldquo;Apache的JDK&rdquo;来说<br />
明。 如果一个公司要宣布自己的运行平台&ldquo;兼容于Java语言&rdquo;，那就必须要通过<br />
TCK（Technology Compatibility Kit）的兼容性测试。 Apache基金会曾要求Sun公司提供TCK的<br />
使用授权，但是一直遭到拒绝，直到Oracle公司收购了Sun公司之后，双方关系越闹越僵，最<br />
终导致Apache愤然退出JCP（Java Community Process）组织，这是目前为止Java社区最严重<br />
的一次&ldquo;分裂&rdquo;。<br />
在Sun将JDK开源形成OpenJDK之后，Apache Harmony开源的优势被极大地削弱，甚至连<br />
Harmony项目的最大参与者IBM公司也宣布辞去Harmony项目管理主席的职位，并参与<br />
OpenJDK项目的开发。 虽然Harmony没有经过真正大规模的商业运用，但是它的许多代码<br />
（基本上是Java库部分的代码）被吸纳进IBM的JDK 7实现及Google Android SDK之中，尤其<br />
是对Android的发展起到了很大的推动作用。<br />
说到Android，这个时下最热门的移动数码设备平台在最近几年间的发展过程中所取得<br />
的成果已经远远超越了Java ME在过去十多年所获得的成果，Android让Java语言真正走进了<br />
移动数码设备领域，只是走的并非Sun公司原本想象的那一条路。<br />
Dalvik VM是Android平台的核心组成部分之一，它的名字来源于冰岛一个名为Dalvik的<br />
小渔村。 Dalvik VM并不是一个Java虚拟机，它没有遵循Java虚拟机规范，不能直接执行Java<br />
的Class文件，使用的是寄存器架构而不是JVM中常见的栈架构。 但是它与Java又有着千丝万<br />
缕的联系，它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，使用Java语<br />
法编写应用程序，可以直接使用大部分的Java API等。 目前Dalvik VM随着Android一起处于<br />
迅猛发展阶段，在Android 2.2中已提供即时编译器实现，在执行性能上有了很大的提高。<br />
1.4.7 Microsoft JVM及其他<br />
在十几年的Java虚拟机发展过程中，除去上面介绍的那些被大规模商业应用过的Java虚<br />
拟机外，还有许多虚拟机是不为人知的或者曾经&ldquo;绚丽&rdquo;过但最终湮灭的。 我们以其中微软公<br />
司的JVM为例来介绍一下。<br />
也许Java程序员听起来可能会觉得惊讶，微软公司曾经是Java技术的铁杆支持者（也必<br />
须承认，与Sun公司争夺Java的控制权，令Java从跨平台技术变为绑定在Windows上的技术是<br />
微软公司的主要目的）。 在Java语言诞生的初期（1996年～1998年，以JDK 1.2发布为分<br />
界），它的主要应用之一是在浏览器中运行Java Applets程序，微软公司为了在IE3中支持<br />
Java Applets应用而开发了自己的Java虚拟机，虽然这款虚拟机只有Windows平台的版本，却<br />
是当时Windows下性能最好的Java虚拟机，它在1997年和1998年连续两年获得了《 PC<br />
Magazine》 杂志的&ldquo;编辑选择奖&rdquo;。 但好景不长，在1997年10月，Sun公司正式以侵犯商标、 不<br />
正当竞争等罪名控告微软公司，在随后对微软公司的垄断调查之中，这款虚拟机也曾作为证<br />
据之一被呈送法庭。 这场官司的结果是微软公司赔偿2000万美金给Sun公司（最终微软公司<br />
因垄断赔偿给Sun公司的总金额高达10亿美元），承诺终止其Java虚拟机的发展，并逐步在<br />
产品中移除Java虚拟机相关功能。 具有讽刺意味的是，到最后在Windows XP SP3中Java虚拟<br />
机被完全抹去的时候，Sun公司却又到处登报希望微软公司不要这样做[1]。 Windows XP高级<br />
产品经理Jim Cullinan称：&ldquo;我们花费了3年的时间和Sun打官司，当时他们试图阻止我们在<br />
Windows中支持Java，现在我们这样做了，可他们又在抱怨，这太具有讽刺意味了。 &rdquo;<br />
我们试想一下，如果当年Sun公司没有起诉微软公司，微软公司继续保持着对Java技术<br />
的热情，那Java的世界会变得怎么样呢？.NET技术是否会发展起来？但历史是没有假设的。<br />
其他在本节中没有介绍到的Java虚拟机还有（当然，应该还有很多笔者所不知道的）：<br />
JamVM.<br />
cacaovm.<br />
SableVM.<br />
Kaffe.<br />
Jelatine JVM.<br />
NanoVM.<br />
MRP.<br />
Moxie JVM.<br />
Jikes RVM.<br />
[1]Sun公司在《 纽约时报》 、 《 圣约瑟商业新闻》 和《 华尔街周刊》 上刊登了整页的广告，<br />
在广告词中Sun公司号召消费者&ldquo;要求微软公司继续在其Windows XP系统包括Java平台&rdquo;。<br />
1.5 展望Java技术的未来<br />
在2005年，Java语言诞生10周年的SunOne技术大会上，Java语言之父James Gosling做了<br />
一场题为&ldquo;Java技术下一个十年&rdquo;的演讲。 笔者不具备James Gosling博士那样高屋建瓴的视<br />
角，这里仅从Java平台中几个新生的但已经开始展现出蓬勃之势的技术发展点来看一下后续<br />
1～2个JDK版本内的一些很有希望的技术重点。<br />
1.5.1 模块化<br />
模块化是解决应用系统与技术平台越来越复杂、 越来越庞大问题的一个重要途径。 无论<br />
是开发人员还是产品最终用户，都不希望为了系统中一小块的功能而不得不下载、 安装、 部<br />
署及维护整套庞大的系统。 站在整个软件工业化的高度来看，模块化是建立各种功能的标准<br />
件的前提。 最近几年OSGi技术的迅速发展、 各个厂商在JCP中对模块化规范的激烈斗争[1]，<br />
都能充分说明模块化技术的迫切和重要。<br />
在未来的Java平台中，很可能会对模块化提出语法层面的支持。 早在2007年，Sun公司<br />
就提出过JSR-277：Java模块系统（Java Module System），试图建立Java平台的模块化标准，<br />
但受挫于以IBM公司为主导提交的JSR-291：Java SE动态组件支持（Dynamic Component<br />
Support for Java SE，这实际就是OSGi R4.1）。 由于模块化规范主导权的重要性，Sun公司不<br />
能接受一个无法由它控制的规范，在整个Java SE 6期间都拒绝把任何模块化技术内置到JDK<br />
之中。 在Java SE 7发展初期，Sun公司再次提交了一个新的规范请求文档JSR-294：Java编程<br />
语言中的改进模块性支持（Improved Modularity Support in the Java Programming Language），<br />
尽管这个JSR仍然没有通过，但是Sun公司已经独立于JCP专家组在OpenJDK里建立了一个名<br />
为Jigsaw（拼图）的子项目来推动这个规范在Java平台中转变为具体的实现。 Java的模块化<br />
之争目前还没有结束，OSGi已经发布到R5.0版本，而Jigsaw从Java 7延迟至Java 8，在2012年<br />
7月又不得不宣布推迟到Java 9中发布，从这点看来，Sun在这场战争中处于劣势，但无论胜<br />
利者是哪一方，Java模块化已经成为一项无法阻挡的变革潮流。<br />
[1]如果读者对Java模块化之争感兴趣，可以阅读笔者的另外一本书《 深入理解OSGi：<br />
Equinox原理、 应用与最佳实践》 的第1章。<br />
1.5.2 混合语言<br />
当单一的Java开发已经无法满足当前软件的复杂需求时，越来越多基于Java虚拟机的语<br />
言开发被应用到软件项目中，Java平台上的多语言混合编程正成为主流，每种语言都可以针<br />
对自己擅长的方面更好地解决问题。 试想一下，在一个项目之中，并行处理用Clojure语言编<br />
写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完<br />
成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像<br />
使用自己语言的原生API一样方便[1]，因为它们最终都运行在一个虚拟机之上。<br />
在最近的几年里，Clojure、 JRuby、 Groovy等新生语言的使用人数不断增长，而运行在<br />
Java虚拟机（JVM）之上的语言数量也在迅速膨胀，图1-4中列举了其中的一部分。 这两点证<br />
明混合编程在我们身边已经有所应用并被广泛认可。 通过特定领域的语言去解决特定领域的<br />
问题是当前软件开发应对日趋复杂的项目需求的一个方向。<br />
图 1-4 可以运行在JVM之上的语言[2]<br />
除了催生出大量的新语言外，许多已经有很长历史的程序语言也出现了基于Java虚拟机<br />
实现的版本，这样使得混合编程对许多以前使用其他语言的&ldquo;老&rdquo;程序员也具备相当大的吸引<br />
力，软件企业投入了大量资本的现有代码资产也能很好地保护起来。 表1-1中列举了常见语<br />
言的JVM实现版本。<br />
对这些运行于Java虚拟机之上、 Java之外的语言，来自系统级的、 底层的支持正在迅速<br />
增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、 Nashorn引擎、<br />
InvokeDynamic指令、 java.lang.invoke包等），推动Java虚拟机从&ldquo;Java语言的虚拟机&rdquo;向&ldquo;多语<br />
言虚拟机&rdquo;的方向发展。<br />
[1]在同一个虚拟机上运行的其他语言与Java之间的交互一般都比较容易，但非Java语言之间<br />
的交互一般都比较烦琐。 dynalang项目（http://dynalang.sourceforge.net/）就是为了解决这个问<br />
题而出现的。<br />
[2]图片来源：http://www.Slideshare.net/josebetomex/oow-2009-towards-a-universal-vm。<br />
1.5.3 多核并行<br />
如今，CPU硬件的发展方向已经从高频率转变为多核心，随着多核时代的来临，软件开<br />
发越来越关注并行编程的领域。 早在JDK 1.5就已经引入java.util.concurrent包实现了一个粗粒<br />
度的并发框架。 而JDK 1.7中加入的java.util.concurrent.forkjoin包则是对这个框架的一次重要<br />
扩充。 Fork/Join模式是处理并行编程的一个经典方法，如图1-5所示。 虽然不能解决所有的问<br />
题，但是在此模式的适用范围之内，能够轻松地利用多个CPU核心提供的计算资源来协作完<br />
成一个复杂的计算任务。 通过利用Fork/Join模式，我们能够更加顺畅地过渡到多核时代。<br />
图 1-5 Fork/Join模式示意图[1]<br />
在Java 8中，将会提供Lambda支持，这将会极大改善目前Java语言不适合函数式编程的<br />
现状（目前Java语言使用函数式编程并不是不可以，只是会显得很臃肿），函数式编程的一<br />
个重要优点就是这样的程序天然地适合并行运行，这对Java语言在多核时代继续保持主流语<br />
言的地位有很大帮助。<br />
另外，在并行计算中必须提及的还有OpenJDK的子项目Sumatra[2]，目前显卡的算术运算<br />
能力、 并行能力已经远远超过了CPU，在图形领域以外发掘显卡的潜力是近几年计算机发展<br />
的方向之一，例如C语言的CUDA。 Sumatra项目就是为Java提供使用GPU（Graphics<br />
Processing Units）和APU（Accelerated Processing Units）运算能力的工具，以后它将会直接提<br />
供Java语言层面的API，或者为Lambda和其他JVM语言提供底层的并行运算支持。<br />
在JDK外围，也出现了专为满足并行计算需求的计算框架，如Apache的Hadoop<br />
Map/Reduce，这是一个简单易懂的并行框架，能够运行在由上千个商用机器组成的大型集群<br />
上，并且能以一种可靠的容错方式并行处理TB级别的数据集。 另外，还出现了诸如Scala、<br />
Clojure及Erlang等天生就具备并行计算能力的语言。<br />
[1]图片来源：http://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/。<br />
[2]Sumatra项目主页：http://openjdk.java.net/projects/sumatra/。<br />
1.5.4 进一步丰富语法<br />
Java 5曾经对Java语法进行了一次扩充，这次扩充加入了自动装箱、 泛型、 动态注解、<br />
枚举、 可变长参数、 遍历循环等语法，使得Java语言的精确性和易用性有了很大的进步。 在<br />
Java 7（由于进度压力，许多改进已推迟至Java 8）中，对Java语法进行了另一次大规模的扩<br />
充。 Sun（已被Oracle收购）专门为改进Java语法在OpenJDK中建立了Coin子项目[1]来统一处<br />
理对Java语法的细节修改，如二进制数的原生支持、 在switch语句中支持字符串、 &ldquo;＜＞&rdquo;操<br />
作符、 异常处理的改进、 简化变长参数方法调用、 面向资源的try-catch-finally语句等都是在<br />
Coin项目之中提交的内容。<br />
除了Coin项目之外，在JSR-335（Lambda Expressions for the Java TM Programming<br />
Language）中定义的Lambda表达式[2]也将对Java的语法和语言习惯产生很大的影响，面向函数<br />
方式的编程可能会成为主流。<br />
[1]Coin项目主页：http://wikis.sun.com/display/ProjectCoin/Home。<br />
[2]Lambda项目主页：http://openjdk.java.net/projects/lambda/。<br />
1.5.5 64位虚拟机<br />
在几年之前，主流的CPU就开始支持64位架构了。 Java虚拟机也在很早之前就推出了支<br />
持64位系统的版本。 但Java程序运行在64位虚拟机上需要付出比较大的额外代价：首先是内<br />
存问题，由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要<br />
消耗更多的内存，通常要比32位系统额外增加10%～30%的内存消耗；其次，多个机构的测<br />
试结果显示，64位虚拟机的运行速度在各个测试项中几乎全面落后于32位虚拟机，两者大约<br />
有15%左右的性能差距。<br />
但是在Java EE方面，企业级应用经常需要使用超过4GB的内存，对于64位虚拟机的需求<br />
是非常迫切的，但由于上述原因，许多企业应用都仍然选择使用虚拟集群等方式继续在32位<br />
虚拟机中进行部署。 Sun也注意到了这些问题，并做出了一些改善，在JDK 1.6 Update 14之<br />
后，提供了普通对象指针压缩功能（-XX：+UseCompressedOops，这个参数不建议显式设<br />
置，建议维持默认由虚拟机的Ergonomics机制自动开启），在执行代码时，动态植入压缩指<br />
令以节省内存消耗，但是开启压缩指针会增加执行代码数量，因为所有在Java堆里的、 指向<br />
Java堆内对象的指针都会被压缩，这些指针的访问就需要更多的代码才可以实现，而且并不<br />
只是读写字段才受影响，在实例方法调用、 子类型检查等操作中也受影响，因为对象实例指<br />
向对象类型的引用也被压缩了。 随着硬件的进一步发展，计算机终究会完全过渡到64位的时<br />
代，这是一件毫无疑问的事情，主流的虚拟机应用也终究会从32位发展至64位，而虚拟机对<br />
64位的支持也将会进一步完善。<br />
1.6 实战：自己编译JDK<br />
想要一探JDK内部的实现机制，最便捷的路径之一就是自己编译一套JDK，通过阅读和<br />
跟踪调试JDK源码去了解Java技术体系的原理，虽然门槛会高一点，但肯定会比阅读各种书<br />
籍、 文章更加贴近本质。 另外，JDK中的很多底层方法都是本地化（Native）的，需要跟踪<br />
这些方法的运作或对JDK进行Hack的时候，都需要自己编译一套JDK。<br />
现在网络上有不少开源的JDK实现可以供我们选择，如Apache Harmony、 OpenJDK等。<br />
考虑到Sun系列的JDK是现在使用得最广泛的JDK版本，笔者选择了OpenJDK进行这次编译实<br />
战。<br />
1.6.1 获取JDK源码<br />
首先要先明确OpenJDK和Sun/OracleJDK之间，以及OpenJDK 6、 OpenJDK 7、 OpenJDK<br />
7u和OpenJDK 8等项目之间是什么关系，这有助于确定接下来编译要使用的JDK版本和源码<br />
分支。<br />
从前面介绍的Java发展史中我们了解到OpenJDK是Sun在2006年末把Java开源而形成的项<br />
目，这里的&ldquo;开源&rdquo;是通常意义上的源码开放形式，即源码是可被复用的，例如IcedTea[1]、<br />
UltraViolet[2]都是从OpenJDK源码衍生出的发行版。 但如果仅从&ldquo;开源&rdquo;字面意义（开放可阅读<br />
的源码）上看，其实Sun自JDK 1.5之后就开始以Java Research License（JRL）的形式公布过<br />
Java源码，主要用于研究人员阅读（JRL许可证的开放源码至JDK 1.6 Update 23为止）。 把这<br />
些JRL许可证形式的Sun/OracleJDK源码和对应版本的OpenJDK源码进行比较，发现除了文件<br />
头的版权注释之外，其余代码基本上都是相同的，只有字体渲染部分存在一点差异，Oracle<br />
JDK采用了商业实现，而OpenJDK使用的是开源的FreeType。 当然，&ldquo;相同&rdquo;是建立在两者共<br />
有的组件基础上的，Oracle JDK中还会存在一些Open JDK没有的、 商用闭源的功能，例如从<br />
JRockit移植改造而来的Java Flight Recorder。 预计以后JRockit的MissionControl移植到HotSpot<br />
之后，也会以Oracle JDK专有、 闭源的形式提供。<br />
Oracle的项目发布经理Joe Darcy在OSCON 2011上对两者关系的介绍[3]也证实了OpenJDK<br />
7和Oracle JDK 7在程序上是非常接近的，两者共用了大量相同的代码（如图1-6所示，注意<br />
图中提示了两者共同代码的占比要远高于图形上看到的比例），所以我们编译的OpenJDK，<br />
基本上可以认为性能、 功能和执行逻辑上都和官方的Oracle JDK是一致的。<br />
图 1-6 OpenJDK和Oracle JDK之间的关系<br />
再来看一下OpenJDK 6、 OpenJDK 7、 OpenJDK 7u和OpenJDK 8这几个项目之间的关系，<br />
从图1-7（依然是从Joe Darcy的OSCON 2011演示稿中截取的图片）来看，OpenJDK 7是始于<br />
JDK 6时期，当时JDK 6和JDK 6 Update 1已经发布，JDK 7已经开始研发了，所以OpenJDK 7<br />
是直接基于正在研发的JDK 7源码建立的。 但考虑到OpenJDK 7的状况在当时还不适合实际生<br />
产部署，因此在OpenJDK 7 Build 20的基础上建立了OpenJDK 6分支，剥离掉JDK 7新功能的<br />
代码，形成一个可以通过TCK 6测试的独立分支。<br />
图 1-7 OpenJDK 6、 OpenJDK 7、 OpenJDK 7u、 OpenJDK 8之间的关系<br />
2012年7月，JDK 7正式发布，在OpenJDK中也同步建立了OpenJDK 7 Update项目对JDK 7<br />
进行更新升级，以及OpenJDK 8项目开始下一个JDK大版本的研发。 按照开发习惯，新的功<br />
能或Bug修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其<br />
他老版本的维护分支上。<br />
OpenJDK 6、 OpenJDK 7、 OpenJDK 7u和OpenJDK 8的源码都可以在它们相应的网页上找<br />
到，在本次编译实践中，笔者选用的项目是OpenJDK 7u，版本为7u6。<br />
获取OpenJDK源码有两种方式，其中一种是通过Mercurial代码版本管理工具从Repository<br />
中直接取得源码（Repository地址：http://hg.openjdk.java.net/jdk7u/jdk7u），获取过程如以下<br />
代码所示。<br />
hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-dev<br />
cd jdk7u-dev<br />
chmod 755 get_source.sh<br />
./get_source.sh<br />
这是最直接的方式，从版本管理中看变更轨迹比看Release Note效果更好。 但不足之处<br />
是速度太慢，虽然代码总容量只有300 MB左右，但是文件数量太多，在笔者的网络下全部<br />
复制到本地需要数小时。 另外，考虑到Mercurial不如Git、 SVN、 ClearCase或CVS之类的版本<br />
控制工具那样普及，对于一般读者，建议采用第二种方式，即直接下载官方打包好的源码<br />
包，读者可以从Source Bundle Releases页面（地址：http://jdk7.java.net/source.html）取得打包<br />
好的源码，到本地直接解压即可。 一般来说，源码包大概一至两个月左右会更新一次，虽然<br />
不够及时，但比起从Mercurial复制代码的确方便和快捷许多。 笔者下载的是OpenJDK 7<br />
Update 6 Build b21版源码包，2012年8月28日发布，大概99MB，解压后约为339MB。<br />
[1]IcedTea：http://icedtea.classpath.org/wiki/Main_Page。<br />
[2]UltraViolet：https://www.reservoir.com/？q=uvform/form。<br />
[3]全文地址：https://blogs.oracle.com/darcy/resource/OSCON/oscon2011_OpenJDKState.pdf。<br />
1.6.2 系统需求<br />
如果可能，笔者建议尽量在Linux、 MacOS或Solaris上构建OpenJDK，这要比在Windows<br />
平台上容易得多，本章实战中笔者将以Ubuntu 10.10和MacOS X 10.8.2为例进行构建。 如果读<br />
者一定要在Windows平台上完成编译，可参考本书附录A，该附录是本书第一版中介绍如何<br />
在Windows下编译OpenJDK 6的例子，原有的部分内容现在已经过时了（例如安装Plug部<br />
分），但还是有一定参考意义，因此笔者没有把它删除掉，而是移到附录之中。<br />
无论在什么平台下进行编译，都建议读者认真阅读一遍源码中的README-builds.html文<br />
档（无论在OpenJDK网站上还是在下载的源码包中都有这份文档），因为编译过程中需要注<br />
意的细节非常多。 虽然不至于像文档上所描述的&ldquo;Building the source code for the JDK requires<br />
a high level of technical expertise.Sun provides the source code primarily for technical experts who<br />
want to conduct research.（编译JDK需要很高的专业技术，Sun提供JDK源码是为了技术专家进<br />
行研究之用）&rdquo;那么夸张，但是如果读者是第一次编译，那有可能会在一些小问题上耗费许<br />
多时间。<br />
在本次编译中采用的是64位操作系统，编译的也是64位的OpenJDK，如果需要编译32位<br />
版本，那建议在32位操作系统上进行。 在官方文档上写到编译OpenJDK至少需要512MB的内<br />
存和600MB的磁盘空间。 512MB的内存也许能凑合使用，不过600MB的磁盘空间估计仅是指<br />
存放OpenJDK源码所需的空间，要完成编译，600MB肯定是无论如何都不够的，光输出的编<br />
译结果就有近3GB（因为有很多中间文件，以及会编译出不同优化级别（Product、 Debug、<br />
FastDebug等）的虚拟机），建议读者至少保证5GB以上的空余磁盘。<br />
对系统的最后一点要求就是所有的文件，包括源码和依赖项目，都不要放在包含中文的<br />
目录里面，这样做不是一定不可以，只是没有必要给自己找麻烦。<br />
1.6.3 构建编译环境<br />
在MacOS[1]和Linux上构建OpenJDK编译环境比较简单（相对于Windows来说），对于Mac<br />
OS，需要安装最新版本的XCode和Command Line Tools for XCode，在Apple Developer网站<br />
（https://developer.apple.com/）上可以免费下载，这两个SDK包提供了OpenJDK所需的编译<br />
器以及Makefile中用到的外部命令。 另外，还要准备一个6u14以上版本的JDK，因为OpenJDK<br />
的各个组成部分（Hotspot、 JDK API、 JAXWS、 JAXP&hellip;&hellip;）有的是使用C++编写的，更多的<br />
代码则是使用Java自身实现的，因此编译这些Java代码需要用到一个可用的JDK，官方称这<br />
个JDK为&ldquo;Bootstrap JDK&rdquo;。 如果编译OpenJDK 7，Bootstrap JDK必须使用JDK6 Update 14或之<br />
后的版本，笔者选用的是JDK7 Update 4。 最后需要下载一个1.7.1以上版本的Apache Ant，用<br />
于执行Java编译代码中的Ant脚本。<br />
对于Linux来说，所需要准备的依赖与Mac OS差不多，Bootstrap JDK和Ant都是一样的，<br />
在Mac OS中GCC编译器来源于XCode SDK，而Ubuntu中GCC应该是默认安装好的，需要确保<br />
版本为4.3以上，如果没有找到GCC，安装binutils即可，在Ubuntu 10.10下编译OpenJDK 7u4所<br />
需的依赖可以使用以下命令一次安装完成。<br />
sudo apt-get install build-essential gawk m4 openjdk-6-jdk<br />
libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev<br />
x11proto-print-dev binutils libmotif3 libmotif-dev ant<br />
[1]注意，只有在OpenJDK 7u4和之后的版本才能编译出Mac OS系统下的JDK包，之前的版本<br />
虽然在源码和编译脚本中也包含了Mac OS目录，但是尚未完善。<br />
1.6.4 进行编译<br />
现在需要下载的编译环境和依赖项目都准备齐全了，最后我们还需要对系统的环境变量<br />
做一些简单设置以便编译能够顺利通过。 OpenJDK在编译时读取的环境变量有很多，但大多<br />
都有默认值，必须设置的只有两个：LANG和ALT_BOOTDIR，前者是设定语言选项，必须<br />
设置为：<br />
export LANG=C<br />
否则，在编译结束前的验证阶段会出现一个HashTable内的空指针异常。 另外一个<br />
ALT_BOOTDIR参数是前面提到的Bootstrap JDK，在Mac OS上笔者设为以下路径，其他操作<br />
系统读者对应调整即可。<br />
export ALT_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0_04.jdk/Contents/Home<br />
另外，如果读者之前设置了JAVA_HOME和CLASSPATH两个环境变量，在编译之前必<br />
须取消，否则在Makefile脚本中检查到有这两个变量存在，会有警告提示。<br />
unset JAVA_HOME<br />
unset CLASSPATH<br />
其他环境变量笔者就不再一一介绍了，代码清单1-1给出笔者自己常用的编译Shell脚<br />
本，读者可以参考变量注释中的内容。<br />
代码清单1-1 环境变量设置<br />
#语言选项，这个必须设置，否则编译好后会出现一个HashTable的NPE错<br />
export LANG=C<br />
#Bootstrap JDK的安装路径。 必须设置<br />
export ALT_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0_04.jdk/Contents/Home<br />
#允许自动下载依赖<br />
export ALLOW_DOWNLOADS=true<br />
#并行编译的线程数，设置为和CPU内核数量一致即可<br />
export HOTSPOT_BUILD_JOBS=6<br />
export ALT_PARALLEL_COMPILE_JOBS=6<br />
#比较本次build出来的映像与先前版本的差异。 这对我们来说没有意义，<br />
#必须设置为false，否则sanity检查会报缺少先前版本JDK的映像的错误提示。<br />
#如果已经设置dev或者DEV_ONLY=true，这个不显式设置也行<br />
export SKIP_COMPARE_IMAGES=true<br />
#使用预编译头文件，不加这个编译会更慢一些<br />
export USE_PRECOMPILED_HEADER=true<br />
#要编译的内容<br />
export BUILD_LANGTOOLS=true<br />
#export BUILD_JAXP=false<br />
#export BUILD_JAXWS=false<br />
#export BUILD_CORBA=false<br />
export BUILD_HOTSPOT=true<br />
export BUILD_JDK=true<br />
#要编译的版本<br />
#export SKIP_DEBUG_BUILD=false<br />
#export SKIP_FASTDEBUG_BUILD=true<br />
#export DEBUG_NAME=debug<br />
#把它设置为false可以避开javaws和浏览器Java插件之类的部分的build<br />
BUILD_DEPLOY=false<br />
#把它设置为false就不会build出安装包。 因为安装包里有些奇怪的依赖，<br />
#但即便不build出它也已经能得到完整的JDK映像，所以还是别build它好了<br />
BUILD_INSTALL=false<br />
#编译结果所存放的路径<br />
export ALT_OUTPUTDIR=/Users/IcyFenix/Develop/JVM/jdkBuild/openjdk_7u4/build<br />
#这两个环境变量必须去掉，不然会有很诡异的事情发生（我没有具体查过这些&quot;诡异的<br />
#事情&quot;，Makefile脚本检查到有这2个变量就会提示警告）<br />
unset JAVA_HOME<br />
unset CLASSPATH<br />
make 2＞＆1|tee $ALT_OUTPUTDIR/build.log<br />
全部设置结束之后，可以输入make sanity来检查我们前面所做的设置是否全部正确。 如<br />
果一切顺利，那么几秒钟之后会有类似代码清单1-2所示的输出。<br />
代码清单1-2 make sanity检查<br />
～/Develop/JVM/jdkBuild/openjdk_7u4$make sanity<br />
Build Machine Information：<br />
build machine=IcyFenix-RMBP.local<br />
Build Directory Structure：<br />
CWD=/Users/IcyFenix/Develop/JVM/jdkBuild/openjdk_7u4<br />
TOPDIR=.<br />
LANGTOOLS_TOPDIR=./langtools<br />
JAXP_TOPDIR=./jaxp<br />
JAXWS_TOPDIR=./jaxws<br />
CORBA_TOPDIR=./corba<br />
HOTSPOT_TOPDIR=./hotspot<br />
JDK_TOPDIR=./jdk<br />
Build Directives：<br />
BUILD_LANGTOOLS=true<br />
BUILD_JAXP=true<br />
BUILD_JAXWS=true<br />
BUILD_CORBA=true<br />
BUILD_HOTSPOT=true<br />
BUILD_JDK=true<br />
DEBUG_CLASSFILES=<br />
DEBUG_BINARIES=<br />
&hellip;&hellip;因篇幅关系，中间省略了大量的输出内容&hellip;&hellip;<br />
OpenJDK-specific settings：<br />
FREETYPE_HEADERS_PATH=/usr/X11R6/include<br />
ALT_FREETYPE_HEADERS_PATH=<br />
FREETYPE_LIB_PATH=/usr/X11R6/lib<br />
ALT_FREETYPE_LIB_PATH=<br />
Previous JDK Settings：<br />
PREVIOUS_RELEASE_PATH=USING-PREVIOUS_RELEASE_IMAGE<br />
ALT_PREVIOUS_RELEASE_PATH=<br />
PREVIOUS_JDK_VERSION=1.6.0<br />
ALT_PREVIOUS_JDK_VERSION=<br />
PREVIOUS_JDK_FILE=<br />
ALT_PREVIOUS_JDK_FILE=<br />
PREVIOUS_JRE_FILE=<br />
ALT_PREVIOUS_JRE_FILE=<br />
PREVIOUS_RELEASE_IMAGE=/Library/Java/JavaVirtualMachines/jdk1.7.0_04.jdk/Contents/Home<br />
ALT_PREVIOUS_RELEASE_IMAGE=<br />
Sanity check passed.<br />
Makefile的Sanity检查过程输出了编译所需的所有环境变量，如果看到&ldquo;Sanity check<br />
passed.&rdquo;，说明检查过程通过了，可以输入&ldquo;make&rdquo;执行整个OpenJDK编译（make不加参数，<br />
默认编译make all），笔者使用Core i7 3720QM/16GB RAM的MacBook机器，启动6条编译线<br />
程，全量编译整个OpenJDK大概需20分钟，编译结束后，将输出类似下面的日志清单所示内<br />
容。 如果读者之前已经全量编译过，只修改了少量文件，增量编译可以在数十秒内完成。<br />
#--Build times----------<br />
Target all_product_build<br />
Start 2012-12-13 17：12：19<br />
End 2012-12-13 17：31：07<br />
00：01：19 corba<br />
00：01：15 hotspot<br />
00：00：14 jaxp<br />
00：7：21 jaxws<br />
00：8：11 jdk<br />
00：00：28 langtools<br />
00：18：48 TOTAL<br />
-------------------------<br />
编译完成之后，进入OpenJDK源码下的build/j2sdk-image目录（或者build-debug、 buildfastdebug这两个目录），这是整个JDK的完整编译结果，复制到JAVA_HOME目录，就可以<br />
作为一个完整的JDK使用，编译出来的虚拟机，在-version命令中带有用户的机器名。<br />
＞./java-version<br />
openjdk version&quot;1.7.0-internal-fastdebug&quot;<br />
O p e n J D K R u n t i m e E n v i r o n m e n t（b u i l d 1.7.0-i n t e r n a l-f a s t d e b u g-icyfenix_2012_12_24_15_57-b00）<br />
OpenJDK 64-Bit Server VM（build 23.0-b21-fastdebug,mixed mode）<br />
在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译<br />
HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速<br />
度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前<br />
面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目<br />
录[1]中，进入后可以见到以下几个目录。<br />
0 drwxr-xr-x 15 IcyFenix staff 510B 12 13 17：24 debug<br />
0 drwxr-xr-x 15 IcyFenix staff 510B 12 13 17：24 fastdebug<br />
0 drwxr-xr-x 15 IcyFenix staff 510B 12 13 17：25 generated<br />
0 drwxr-xr-x 15 IcyFenix staff 510B 12 13 17：24 jvmg<br />
0 drwxr-xr-x 15 IcyFenix staff 510B 12 13 17：24 optimized<br />
0 drwxr-xr-x 584 IcyFenix staff 19K 12 13 17：25 product<br />
0 drwxr-xr-x 15 IcyFenix staff 510B 12 13 17：24 profiled<br />
这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源<br />
码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。<br />
在编译结束之后、 运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编<br />
译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了&ldquo;JAVA_HOME、<br />
CLASSPATH、 HOTSPOT_BUILD_USER&rdquo;3个环境变量，还需要增加一<br />
个&ldquo;LD_LIBRARY_PATH&rdquo;，内容如下：<br />
LD_LIBRARY_PATH=.：${JAVA_HOME}/jre/lib/amd64/native_threads：${JAVA_HOME}/jre/lib/amd64：<br />
export LD_LIBRARY_PATH<br />
然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。<br />
../env.sh<br />
./gamma-version<br />
Using java runtime at：/Library/Java/JavaVirtualMachines/jdk1.7.0_04.jdk/Contents/Home/jre<br />
java version&quot;1.7.0_04&quot;<br />
Java（TM）SE Runtime Environment（build 1.7.0_04-b21）<br />
OpenJDK 64-Bit Server VM（build 23.0-b21，mixed mode）<br />
看到自己编译的虚拟机成功运行起来，很有成就感吧！<br />
[1]在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为<br />
FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表<br />
示是compiler1）。<br />
1.6.5 在IDE工具中进行源码调试<br />
在阅读OpenJDK源码的过程中，经常需要运行、 调试程序来帮助理解。 我们现在已经可<br />
以编译出一个调试版本HotSpot虚拟机，禁用优化，并带有符号信息，这样就可以使用GDB<br />
来进行调试了。 据笔者了解，许多对虚拟机了解比较深的开发人员确实就是直接使用GDB加<br />
VIM编辑器来开发、 修改HotSpot的，不过相信大部分读者更倾向于在IDE环境而不是纯文本<br />
的GDB下阅读、 跟踪HotSpot源码，因此这节就简单介绍一下&ldquo;如何在IDE中进行HotSpot源码<br />
调试&rdquo;。<br />
首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans，下载时选择支持<br />
C/C++开发的那个版本。 安装后，新建一个项目，选择&ldquo;基于现有源代码的C/C++项目&rdquo;，在<br />
源码文件夹中填入OpenJDK目录下hotspot目录的路径，在下面的单选按钮中选择&ldquo;定制&rdquo;，如<br />
图1-8所示，然后单击&ldquo;下一步&rdquo;按钮。<br />
图 1-8 在NetBeans中创建HotSpot项目（1）<br />
接着，在&ldquo;指定构建代码的方法&rdquo;中选择&ldquo;使用现有的makefile&rdquo;，并填入Makefile文件的路<br />
径（在hotspot/make目录下），如图1-9所示。 单击&ldquo;下一步&rdquo;按钮，将&ldquo;构建命令&rdquo;修改为以下<br />
内容：<br />
${MAKE}-f Makefile clean jvmg<br />
ALT_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.7.0_04.jdk/Contents/Home ARCH_DATA_MODEL=64 LANG=C<br />
图 1-9 在NetBeans中创建HotSpot项目（2）<br />
OpenJDK 7u4源码Makefile在终端运行时能正确获取到系统指令集架构为64位，但在<br />
NetBeans中却没有取得正确的值，误认为是32位，因此这里必须使用ARCH_DATA_MODEL<br />
参数明确指定为64位。 另外两个参数ALT_BOOTDIR和LANG的作用前面已经介绍过。 单<br />
击&ldquo;完成&rdquo;按钮，HotSpot项目就这样导入到NetBeans中了。<br />
不过，这时候HotSpot还运行不起来，因为NetBeans根本不知道编译出来的结果放在哪<br />
里、 哪个程序是虚拟机的入口等，这些内容都需要明确告知NetBeans。 在HotSpot工程上单击<br />
右键，在弹出的快捷菜单中选择&ldquo;属性&rdquo;，在弹出的对话框中找到&ldquo;运行&rdquo;选项，设置运行命令<br />
为：<br />
/Users/IcyFenix/Develop/JVM/jdkBuild/openjdk_7u4/hotspot/build/bsd/bsd_amd64_compiler2/jvmg/gamma Queens<br />
上面的Queens是Makefile脚本自动产生的一段解八皇后问题的Java程序，用于测试虚拟<br />
机，这里笔者直接拿来用了，读者完全可以将它替换为自己的Java程序。<br />
读者在调试Java代码执行时，如果要跟踪具体Java代码在虚拟机中是如何执行的，也许<br />
会觉得无从下手，因为目前在HotSpot主流的操作系统上，都采用模板解释器来执行字节<br />
码，它与JIT编译器一样，最终执行的汇编代码都是运行期间产生的，无法直接设置断点，<br />
所以HotSpot增加了以下参数来方便开发人员调试解释器。<br />
-XX：+TraceBytecodes-XX：StopInterpreterAt=＜n＞<br />
这组参数的作用是当遇到序号为＜n＞的字节码指令时，便会中断程序执行，进入断点<br />
调试。 在调试解释器部分代码时，把这两个参数加到gamma后面即可。<br />
最后，还需要在&ldquo;环境&rdquo;窗口中设置环境变量，也就是前面env.sh脚本所设置的那几个环<br />
境变量，如图1-10所示。<br />
图 1-10 在NetBeans中创建HotSpot项目（3）<br />
完成以上配置之后，一个可修改、 编译、 调试的HotSpot工程就完全建立起来了，启动<br />
器的执行入口是java.c的main（）方法，读者可以设置断点单步跟踪，如图1-11所示。<br />
图 1-11 在NetBeans中创建HotSpot项目（4）<br />
由于HotSpot的源码比较长，C/C++文件数量也很多，为了便于读者阅读，所以代码清单<br />
1-3给出了各个目录中代码的主要用途，供读者参考。<br />
代码清单1-3 HotSpot源码结构[1]</p>

<p>[1]该目录结构由RednaxelaFX整理：http://hllvm.group.iteye.com/group/topic/26998。<br />
1.7 本章小结<br />
本章介绍了Java技术体系的过去、 现在以及未来的一些发展趋势，并通过实战介绍了如<br />
何自己来独立编译一个OpenJDK 7。 作为全书的引言部分，本章建立了后文研究所必需的环<br />
境。 在了解Java技术的来龙去脉后，后面章节将分为4部分去介绍Java在内存管理、 Class文<br />
件结构与执行引擎、 编译器优化及多线程并发方面的实现原理。<br />
&nbsp;</p>
