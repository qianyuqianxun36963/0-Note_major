<h1>理解java动态代理</h1>

<h2>代理设计模式</h2>

<p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p>

<p>代理模式的结构如下图所示。</p>

<h2>动态代理使用</h2>

<p>java动态代理机制以巧妙的方式实现了代理模式的设计理念。</p>

<p>代理模式示例代码</p>

<p>public interface Subject { public void doSomething(); } public class RealSubject implements Subject { public void doSomething() { System.out.println( &quot;call doSomething()&quot; ); } } public class ProxyHandler implements InvocationHandler { private Object proxied; public ProxyHandler( Object proxied ) { this.proxied = proxied; } public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable { //在转调具体目标对象之前，可以执行一些功能处理 //转调具体目标对象的方法 return method.invoke( proxied, args); //在转调具体目标对象之后，可以执行一些功能处理 } }</p>

<pre>
import java.lang.reflect.InvocationHandler;   
import java.lang.reflect.Method;   
import java.lang.reflect.Proxy;   
import sun.misc.ProxyGenerator;   
import java.io.*;   
public class DynamicProxy   
{   
  public static void main( String args[] )   
  {   
    RealSubject real = new RealSubject();   
    Subject proxySubject = (Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(), 
     new Class[]{Subject.class}, 
     new ProxyHandler(real));
         
    proxySubject.doSomething();
   
    //write proxySubject class binary data to file   
    createProxyClassFile();   
  }   
     
  public static void createProxyClassFile()   
  {   
    String name = &quot;ProxySubject&quot;;   
    byte[] data = ProxyGenerator.generateProxyClass( name, new Class[] { Subject.class } );   
    try  
    {   
      FileOutputStream out = new FileOutputStream( name + &quot;.class&quot; );   
      out.write( data );   
      out.close();   
    }   
    catch( Exception e )   
    {   
      e.printStackTrace();   
    }   
  }   
}  </pre>

<p>&nbsp;</p>

<h2>动态代理内部实现</h2>

<p>首先来看看类<strong>Proxy</strong>的代码实现&nbsp;<strong>Proxy</strong>的主要静态变量</p>

<p>&nbsp;</p>

<pre>
// 映射表：用于维护类装载器对象到其对应的代理类缓存
private static Map loaderToCache = new WeakHashMap(); 

// 标记：用于标记一个动态代理类正在被创建中
private static Object pendingGenerationMarker = new Object(); 

// 同步表：记录已经被创建的动态代理类类型，主要被方法 isProxyClass 进行相关的判断
private static Map proxyClasses = Collections.synchronizedMap(new WeakHashMap()); 

// 关联的调用处理器引用
protected InvocationHandler h;</pre>

<p>&nbsp;</p>

<h3><strong>Proxy</strong>的构造方法</h3>

<pre>
// 由于 Proxy 内部从不直接调用构造函数，所以 private 类型意味着禁止任何调用
private Proxy() {} 

// 由于 Proxy 内部从不直接调用构造函数，所以 protected 意味着只有子类可以调用
protected Proxy(InvocationHandler h) {this.h = h;} </pre>

<h3><strong>Proxy</strong>静态方法<strong>newProxyInstance</strong></h3>

<p>&nbsp;</p>

<pre>
public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h) throws IllegalArgumentException { 
    // 检查 h 不为空，否则抛异常
    if (h == null) { 
        throw new NullPointerException(); 
    } 

    // 获得与指定类装载器和一组接口相关的代理类类型对象
    Class cl = getProxyClass(loader, interfaces); 

    // 通过反射获取构造函数对象并生成代理类实例
    try { 
        Constructor cons = cl.getConstructor(constructorParams); 
        return (Object) cons.newInstance(new Object[] { h }); 
    } catch (NoSuchMethodException e) { throw new InternalError(e.toString()); 
    } catch (IllegalAccessException e) { throw new InternalError(e.toString()); 
    } catch (InstantiationException e) { throw new InternalError(e.toString()); 
    } catch (InvocationTargetException e) { throw new InternalError(e.toString()); 
    } 
}</pre>

<p>&nbsp;</p>

<p>类<strong>Proxy</strong>的<strong>getProxyClass</strong>方法调用<strong>ProxyGenerator</strong>的&nbsp;<strong>generateProxyClass</strong>方法产生ProxySubject.class的二进制数据：</p>

<pre>
public static byte[] generateProxyClass(final String name, Class[] interfaces)</pre>

<p>我们可以<strong>import sun.misc.ProxyGenerator</strong>，调用&nbsp;<strong>generateProxyClass</strong>方法产生binary data，然后写入文件，最后通过反编译工具来查看内部实现原理。 反编译后的<strong>ProxySubject.java</strong>&nbsp;<strong>Proxy</strong>静态方法<strong>newProxyInstance</strong></p>

<p>&nbsp;</p>

<pre>
import java.lang.reflect.*;   
public final class ProxySubject extends Proxy   
    implements Subject   
{   
    private static Method m1;   
    private static Method m0;   
    private static Method m3;   
    private static Method m2;   
    public ProxySubject(InvocationHandler invocationhandler)   
    {   
        super(invocationhandler);   
    }   
    public final boolean equals(Object obj)   
    {   
        try  
        {   
            return ((Boolean)super.h.invoke(this, m1, new Object[] {   
                obj   
            })).booleanValue();   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final int hashCode()   
    {   
        try  
        {   
            return ((Integer)super.h.invoke(this, m0, null)).intValue();   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final void doSomething()   
    {   
        try  
        {   
            super.h.invoke(this, m3, null);   
            return;   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final String toString()   
    {   
        try  
        {   
            return (String)super.h.invoke(this, m2, null);   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    static    
    {   
        try  
        {   
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] {   
                Class.forName(&quot;java.lang.Object&quot;)   
            });   
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);   
            m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;doSomething&quot;, new Class[0]);   
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);   
        }   
        catch(NoSuchMethodException nosuchmethodexception)   
        {   
            throw new NoSuchMethodError(nosuchmethodexception.getMessage());   
        }   
        catch(ClassNotFoundException classnotfoundexception)   
        {   
            throw new NoClassDefFoundError(classnotfoundexception.getMessage());   
        }   
    }   
}  
</pre>

<p><a href="http://www.docjar.com/html/api/sun/misc/ProxyGenerator.java.html">ProxyGenerator</a>内部是如何生成class二进制数据，可以参考源代码。</p>

<pre>
private byte[] generateClassFile() {   
  /*  
   * Record that proxy methods are needed for the hashCode, equals,  
   * and toString methods of java.lang.Object.  This is done before  
   * the methods from the proxy interfaces so that the methods from  
   * java.lang.Object take precedence over duplicate methods in the  
   * proxy interfaces.  
   */  
  addProxyMethod(hashCodeMethod, Object.class);   
  addProxyMethod(equalsMethod, Object.class);   
  addProxyMethod(toStringMethod, Object.class);   
  /*  
   * Now record all of the methods from the proxy interfaces, giving  
   * earlier interfaces precedence over later ones with duplicate  
   * methods.  
   */  
  for (int i = 0; i &lt; interfaces.length; i++) {   
      Method[] methods = interfaces[i].getMethods();   
      for (int j = 0; j &lt; methods.length; j++) {   
    addProxyMethod(methods[j], interfaces[i]);   
      }   
  }   
  /*  
   * For each set of proxy methods with the same signature,  
   * verify that the methods&#39; return types are compatible.  
   */  
  for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {   
      checkReturnTypes(sigmethods);   
  }   
  /* ============================================================  
   * Step 2: Assemble FieldInfo and MethodInfo structs for all of  
   * fields and methods in the class we are generating.  
   */  
  try {   
      methods.add(generateConstructor());   
      for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {   
    for (ProxyMethod pm : sigmethods) {   
        // add static field for method&#39;s Method object   
        fields.add(new FieldInfo(pm.methodFieldName,   
      &quot;Ljava/lang/reflect/Method;&quot;,   
       ACC_PRIVATE | ACC_STATIC));   
        // generate code for proxy method and add it   
        methods.add(pm.generateMethod());   
    }   
      }   
      methods.add(generateStaticInitializer());   
  } catch (IOException e) {   
      throw new InternalError(&quot;unexpected I/O Exception&quot;);   
  }   
  /* ============================================================  
   * Step 3: Write the final class file.  
   */  
  /*  
   * Make sure that constant pool indexes are reserved for the  
   * following items before starting to write the final class file.  
   */  
  cp.getClass(dotToSlash(className));   
  cp.getClass(superclassName);   
  for (int i = 0; i &lt; interfaces.length; i++) {   
      cp.getClass(dotToSlash(interfaces[i].getName()));   
  }   
  /*  
   * Disallow new constant pool additions beyond this point, since  
   * we are about to write the final constant pool table.  
   */  
  cp.setReadOnly();   
  ByteArrayOutputStream bout = new ByteArrayOutputStream();   
  DataOutputStream dout = new DataOutputStream(bout);   
  try {   
      /*  
       * Write all the items of the &quot;ClassFile&quot; structure.  
       * See JVMS section 4.1.  
       */  
          // u4 magic;   
      dout.writeInt(0xCAFEBABE);   
          // u2 minor_version;   
      dout.writeShort(CLASSFILE_MINOR_VERSION);   
          // u2 major_version;   
      dout.writeShort(CLASSFILE_MAJOR_VERSION);   
      cp.write(dout);   // (write constant pool)   
          // u2 access_flags;   
      dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);   
          // u2 this_class;   
      dout.writeShort(cp.getClass(dotToSlash(className)));   
          // u2 super_class;   
      dout.writeShort(cp.getClass(superclassName));   
          // u2 interfaces_count;   
      dout.writeShort(interfaces.length);   
          // u2 interfaces[interfaces_count];   
      for (int i = 0; i &lt; interfaces.length; i++) {   
    dout.writeShort(cp.getClass(   
        dotToSlash(interfaces[i].getName())));   
      }   
          // u2 fields_count;   
      dout.writeShort(fields.size());   
          // field_info fields[fields_count];   
      for (FieldInfo f : fields) {   
    f.write(dout);   
      }   
          // u2 methods_count;   
      dout.writeShort(methods.size());   
          // method_info methods[methods_count];   
      for (MethodInfo m : methods) {   
    m.write(dout);   
      }   
             // u2 attributes_count;   
      dout.writeShort(0); // (no ClassFile attributes for proxy classes)   
  } catch (IOException e) {   
      throw new InternalError(&quot;unexpected I/O Exception&quot;);   
  }   
  return bout.toByteArray(); 
</pre>

<h2>总结</h2>

<p>一个典型的动态代理创建对象过程可分为以下四个步骤：<br />
1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);<br />
2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<br />
Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});<br />
3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<br />
Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});<br />
4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<br />
Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));<br />
为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。<br />
生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）</p>

<h2>美中不足</h2>

<p>诚然，<strong>Proxy</strong>已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持<strong>interface</strong>代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫<strong>Proxy</strong>。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。</p>

<p>&nbsp;</p>

<h2>Proxy.getProxyClass()方法示例</h2>

<p>&nbsp;</p>

<p>通过Proxy.getProxyClass()来获取类的构造方法和类的方法</p>

<pre>
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Collection;

public class GetClassConstrutorAndMethod {

    /**
     * @param args
     * @author liuyue
     */

    public static void main(String[] args) {
        // TODO Auto-generated method stub  
        //使用Proxy.getProxtClass(loader,class)方法来获取一个类的字节码  
        Class&lt;?&gt; clazzCollection = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);


        System.out.println(&quot;-------there are Cons--------&quot;);    //为了打印结果好看, 添加了一个标题  
        ArrayList&lt;String&gt; LotOfCons = getConstructors(clazzCollection);   //创建一个数组来保存返回的构造方法  
        for(int i = 0; i&lt;LotOfCons.size(); i++){ //由于直接打印ArrayList很不好看, 所有的都显示成一行, 所以循环打印  
            System.out.println((i+1)+&quot; &quot;+LotOfCons.get(i));
        }

        System.out.println();

        System.out.println(&quot;-------there are Mets--------&quot;);    //同上, 只不过这是方法  
        ArrayList&lt;String&gt; LotOfMets = getMethods(clazzCollection);
        for(int i = 0; i&lt;LotOfMets.size(); i++){
            System.out.println((i+1)+&quot; &quot;+LotOfMets.get(i));
        }
    }


    //返回构造方法的方法, 要求传递一个Class类型的参数, 譬如通过Proxy.getProxyClass()获取的值;  
    public static ArrayList&lt;String&gt; getConstructors(Class&lt;?&gt; clazzYouWant){

        Constructor[] cons = clazzYouWant.getConstructors();    //通过反射获得构造方法  
        ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();

        for(Constructor&lt;?&gt; con : cons){   //遍历获得的构造方法们, 对每一个构造方法获取参数  
            String ConstructorName = con.getName();
            StringBuilder sb = new StringBuilder();
            //构造方法返回的是一长串字符, 像这样com.sun.proxy.$Proxy0(interface java.lang.reflect.InvocationHandler)  
            //很不爽, 于是截取$符号之后的字符作为构造方法名称  
            ConstructorName = ConstructorName.substring(ConstructorName.lastIndexOf(&quot;$&quot;)+1,ConstructorName.length());

            sb.append(ConstructorName); //拼接字符串形成function(param,param)这种形式  
            sb.append(&#39;(&#39;);

            Class[] clazzParams = con.getParameterTypes();  //获取参数们  
            for(Class&lt;?&gt; clazzParam : clazzParams){   //把参数拼接到字符串内, 并在每个参数后加逗号.  
                sb.append(clazzParam);
                sb.append(&#39;,&#39;);
            }

            //最后一个逗号是多余的, 删除掉. 判断条件是clazzParams不为空或者clazzParams的长度不为0, 则删除末尾的字符.  
            // 但是使用||不对, 在没有参数的时候会删除掉小括号的前半部分; 应该使用&amp;&amp;就没问题了, 不知道为什么, 谁解答一下?  
            if(clazzParams!=null||clazzParams.length !=0){
                sb.deleteCharAt(sb.length()-1);
            }
            sb.append(&#39;)&#39;);
            al.add(sb.toString());
        }

        return al;
    }


    ////返回类的所有方法的方法, 完全同上  
    public static ArrayList&lt;String&gt; getMethods(Class&lt;?&gt; clazzYouWant){

        Method[] cons = clazzYouWant.getMethods();
        ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();

        for(Method con : cons){
            String name = con.getName();
            Class[] clazzParams = con.getParameterTypes();
            StringBuilder sb = new StringBuilder();

            sb.append(name);
            sb.append(&#39;(&#39;);

            for(Class&lt;?&gt; clazzParam : clazzParams){
                sb.append(clazzParam.getName());
                sb.append(&#39;,&#39;);
            }

            if(clazzParams!=null &amp;&amp; clazzParams.length !=0){
                sb.deleteCharAt(sb.length()-1);
            }
            sb.append(&#39;)&#39;);
            al.add(sb.toString());
        }

        return al;
    }

}  </pre>
