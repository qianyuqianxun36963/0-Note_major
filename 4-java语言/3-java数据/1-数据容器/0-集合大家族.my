<h1><span style="font-size:22px"><a href="http://blog.csdn.net/chenssy/article/details/17732841">java提高篇（二十）集合大家族</a></span></h1>

<p>在编写<a href="http://lib.csdn.net/base/javase" target="_blank" title="Java SE知识库">Java</a>程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！</p>

<p><img alt="" src="http://img.blog.csdn.net/20140101105109140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)，更加详细的介绍会在不久的将来一一讲解。</p>

<h1>一、Collection接口</h1>

<p>&nbsp;&nbsp;&nbsp;Collection接口是最基本的集合接口，它不提供直接的实现，<a href="http://lib.csdn.net/base/java" target="_blank" title="Java 知识库">Java&nbsp;</a>SDK提供的类都是继承自Collection的&ldquo;子接口&rdquo;如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p>

<p>&nbsp;&nbsp;&nbsp;在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p>

<h1>二、List接口</h1>

<p>&nbsp;&nbsp;&nbsp;List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>

<h3>2.1、ArrayList</h3>

<p>&nbsp;&nbsp;&nbsp;ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p>

<p>&nbsp;&nbsp;&nbsp;size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p>

<p>ArrayList擅长于随机访问。同时ArrayList是非同步的。</p>

<h3>2.2、LinkedList</h3>

<p>&nbsp;&nbsp;&nbsp;同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p>

<p>&nbsp;&nbsp;&nbsp;由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p>

<p>&nbsp;&nbsp;&nbsp;与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：&nbsp;<br />
List list = Collections.synchronizedList(new LinkedList(...));</p>

<h3>2.3、Vector</h3>

<p>&nbsp;&nbsp;&nbsp;与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p>

<h3>2.4、Stack</h3>

<p>&nbsp;&nbsp;&nbsp;Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法<a href="http://lib.csdn.net/base/softwaretest" target="_blank" title="软件测试知识库">测试</a>堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>

<h1>三、Set接口</h1>

<p>&nbsp;&nbsp;&nbsp;Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p>

<h3>3.1、HashSet</h3>

<p>&nbsp;&nbsp;&nbsp;HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。</p>

<h3>3.2、TreeSet</h3>

<p>&nbsp;&nbsp;&nbsp;基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的<code>Comparator</code>&nbsp;进行排序，具体取决于使用的构造方法。</p>

<h3>3.3、EnumSet</h3>

<p>&nbsp;&nbsp;&nbsp;是枚举的专用Set。所有的元素都是枚举类型。</p>

<h1>四、Map接口</h1>

<p>&nbsp;&nbsp;&nbsp;Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p>

<h3>4.1、HashMap</h3>

<p>&nbsp;&nbsp;&nbsp;以哈希表<a href="http://lib.csdn.net/base/datastructure" target="_blank" title="算法与数据结构知识库">数据结构</a>实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p>

<h3>4.2、TreeMap</h3>

<p>&nbsp;&nbsp;&nbsp;键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口</p>

<h3>4.3、EnumMap</h3>

<p>&nbsp;&nbsp;&nbsp;与枚举类型键一起使用的专用 <a href="../../java/util/Map.html" title="java.util 中的接口"><code>Map</code></a> 实现。枚举映射中所有键都必须来自单个枚举类型，该枚举类型在创建映射时显式或隐式地指定。枚举映射在内部表示为数组。此表示形式非常紧凑且高效。</p>

<h3>4.4、HashTable</h3>

<p>&nbsp;&nbsp;&nbsp;也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低&nbsp;</p>

<h3>4.5、Properties</h3>

<p>&nbsp; &nbsp;&nbsp;<code>Properties</code> 类表示了一个持久的属性集。<code>Properties</code> 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p>

<h1>五、Queue</h1>

<p>&nbsp;&nbsp;&nbsp;队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p>

<h1>六、异同点</h1>

<p>&nbsp;&nbsp;&nbsp;出处：<a href="http://blog.csdn.net/softwave/article/details/4166598" target="_blank" title="http://blog.csdn.net/softwave/article/details/4166598">http://blog.csdn.net/softwave/article/details/4166598</a></p>

<h3>6.1、Vector和ArrayList</h3>

<p>&nbsp;&nbsp;&nbsp;1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。&nbsp;<br />
&nbsp;&nbsp;&nbsp;2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。&nbsp;<br />
&nbsp;&nbsp;&nbsp;3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</p>

<p>&nbsp;&nbsp;&nbsp;ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p>

<h3>6.2、A<strong>arraylist和Linkedlist</strong></h3>

<p>&nbsp;&nbsp;&nbsp;1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。&nbsp;<br />
&nbsp;&nbsp;&nbsp;2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。&nbsp;<br />
&nbsp;&nbsp;&nbsp;3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。&nbsp;<br />
这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p>

<h3>6.3、HashMap与TreeMap</h3>

<p>&nbsp;&nbsp;&nbsp;1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。</p>

<p>&nbsp;&nbsp;&nbsp;2、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架&rdquo;提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。</p>

<p>&nbsp;&nbsp;&nbsp;3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。</p>

<h3>6.4、hashtable与hashmap</h3>

<p>&nbsp;&nbsp;&nbsp;1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</p>

<p>&nbsp;&nbsp;&nbsp;2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</p>

<p>&nbsp;&nbsp;&nbsp;3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。</p>

<h1>七、对集合的选择</h1>

<h3>7.1、对List的选择</h3>

<p>&nbsp;&nbsp;&nbsp;1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList</p>

<p>&nbsp;&nbsp;&nbsp;2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。</p>

<p>&nbsp;&nbsp;&nbsp;3、对于Vector而已，我们一般都是避免使用。</p>

<p>&nbsp;&nbsp;&nbsp;4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。</p>

<h3>7.2、对Set的选择</h3>

<p>&nbsp;&nbsp;&nbsp;1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。</p>

<p>&nbsp;&nbsp;&nbsp;3、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。</p>

<h3>7.3、对Map的选择</h3>

<p>&nbsp;&nbsp;&nbsp;1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。</p>

<p>&nbsp;&nbsp;&nbsp;2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。</p>

<h1>八、使用技巧</h1>

<p><code>8.1.一般情况下,如果没有必要,推荐代码只同List,Map接口打交道.</code></p>

<p><code>　　比如:List list =&nbsp;</code><code>new</code>&nbsp;<code>ArrayList();</code></p>

<p><code>　　这样做的原因是list就相当于是一个泛型的实现,如果想改变list的类型,只需要:</code></p>

<p><code>　　List list =&nbsp;</code><code>new</code>&nbsp;<code>LinkedList();</code><code>//LinkedList也是List的实现类,也是ArrayList的兄弟类</code></p>

<p><code>　　这样,就不需要修改其它代码,这就是接口编程的优雅之处.</code></p>

<p><code>　　另外的例子就是,在类的方法中,如下声明:</code></p>

<p><code>　　</code><code>private</code>&nbsp;<code>void</code>&nbsp;<code>doMyAction(List list){}</code></p>

<p><code>　　这样这个方法能处理所有实现了List接口的类,一定程度上实现了泛型函数.</code></p>
