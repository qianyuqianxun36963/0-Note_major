<h1>MYSQL查询语句优化</h1>

<blockquote>
<p>mysql的性能优化包罗甚广： 索引优化，查询优化，查询缓存，服务器设置优化，操作系统和硬件优化，应用层面优化（web服务器，缓存）等等。这里的记录的优化技巧更适用于开发人员，都是从网络上收集和自己整理的，主要是查询语句上面的优化，其它层面的优化技巧在此不做记录。</p>
</blockquote>

<p><strong>查询的开销指标：</strong></p>

<blockquote>
<p>执行时间 检查的行数 返回的行数</p>
</blockquote>

<p><strong>建立索引的几个准则：</strong></p>

<blockquote>
<p>1、合理的建立索引能够加速数据读取效率，不合理的建立索引反而会拖慢数据库的响应速度。 2、索引越多，更新数据的速度越慢。 3、尽量在采用MyIsam作为引擎的时候使用索引（因为MySQL以BTree存储索引），而不是InnoDB。但MyISAM不支持Transcation。 4、当你的程序和数据库结构/SQL语句已经优化到无法优化的程度，而程序瓶颈并不能顺利解决，那就是应该考虑使用诸如memcached这样的分布式缓存系统的时候了。 5、习惯和强迫自己用EXPLAIN来分析你SQL语句的性能。</p>
</blockquote>

<p><strong>1. count的优化</strong></p>

<blockquote>
<p>比如：计算id大于5的城市 a. select count(*) from world.city where id &gt; 5; b. select (select count(*) from world.city) &ndash; count(*) from world.city where id &lt;= 5; a语句当行数超过11行的时候需要扫描的行数比b语句要多， b语句扫描了6行，此种情况下，b语句比a语句更有效率。当没有where语句的时候直接select count(*) from world.city这样会更快，因为mysql总是知道表的行数。</p>
</blockquote>

<p><strong>2. 避免使用不兼容的数据类型。</strong></p>

<blockquote>
<p>例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。 在程序中，保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如 SELECT * FROM T1语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM T1；在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。不要在应用中使用数据库游标，游标是非常有用的工具，但比使用常规的、面向集的SQL语句需要更大的开销；按照特定顺序提取数据的查找。</p>
</blockquote>

<p><strong>3. 索引字段上进行运算会使索引失效。</strong></p>

<blockquote>
<p>尽量避免在WHERE子句中对字段进行函数或表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： SELECT * FROM T1 WHERE F1/2=100 应改为: SELECT * FROM T1 WHERE F1=100*2</p>
</blockquote>

<p><strong>4. 避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符.</strong></p>

<blockquote>
<p>因为这会使系统无法使用索引,而只能直接搜索表中的数据。例如: SELECT id FROM employee WHERE id != &ldquo;B%&rdquo; 优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。在in语句中能用exists语句代替的就用exists.</p>
</blockquote>

<p><strong>5. 尽量使用数字型字段.</strong></p>

<blockquote>
<p>一部分开发人员和数据库管理人员喜欢把包含数值信息的字段 设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</blockquote>

<p><strong>6. 合理使用EXISTS,NOT EXISTS子句。如下所示：</strong></p>

<blockquote>
<p>1.SELECT SUM(T1.C1) FROM T1 WHERE (SELECT COUNT(*)FROM T2 WHERE T2.C2=T1.C2&gt;0) 2.SELECT SUM(T1.C1) FROM T1WHERE EXISTS(SELECT * FROM T2 WHERE T2.C2=T1.C2) 两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。如果你想校验表里是否存在某条纪录，不要用count(*)那样效率很低，而且浪费服务器资源。可以用EXISTS代替。如： IF (SELECT COUNT(*) FROM table_name WHERE column_name = &lsquo;xxx&rsquo;)可以写成：IF EXISTS (SELECT * FROM table_name WHERE column_name = &lsquo;xxx&rsquo;)</p>
</blockquote>

<p><strong>7. 能够用BETWEEN的就不要用IN</strong></p>

<p><strong>8. 能够用DISTINCT的就不用GROUP BY</strong></p>

<p><strong>9. 尽量不要用SELECT INTO语句。SELECT INTO 语句会导致表锁定，阻止其他用户访问该表。</strong></p>

<p><strong>10. 必要时强制查询优化器使用某个索引</strong></p>

<blockquote>
<p>SELECT * FROM T1 WHERE nextprocess = 1 AND processid IN (8,32,45) 改成： SELECT * FROM T1 (INDEX = IX_ProcessID) WHERE nextprocess = 1 AND processid IN (8,32,45) 则查询优化器将会强行利用索引IX_ProcessID 执行查询。</p>
</blockquote>

<p><strong>11. 消除对大型表行数据的顺序存取</strong></p>

<blockquote>
<p>尽管在所有的检查列上都有索引，但某些形式的WHERE子句强迫优化器使用顺序存取。如： SELECT * FROM orders WHERE (customer_num=104 AND order_num&gt;1001) OR order_num=1008 解决办法可以使用并集来避免顺序存取： SELECT * FROM orders WHERE customer_num=104 AND order_num&gt;1001 UNION SELECT * FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。【jacking 数据结果集很多，但查询条件限定后结果集不大的情况下，后面的语句快】</p>
</blockquote>

<p><strong>12. 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。</strong></p>

<blockquote>
<p>见如下例子： SELECT * FROM T1 WHERE NAME LIKE &lsquo;%L%&rsquo; SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=&rsquo;L&rsquo; SELECT * FROM T1 WHERE NAME LIKE &lsquo;L%&rsquo; 即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作，不要习惯性的使用 &lsquo;%L%&rsquo;这种方式(会导致全表扫描)，如果可以使用`L%&rsquo;相对来说更好;</p>
</blockquote>

<p><strong>13. 虽然UPDATE、DELETE语句的写法基本固定，但是还是对UPDATE语句给点建议：</strong></p>

<blockquote>
<p>a) 尽量不要修改主键字段。 b) 当修改VARCHAR型字段时，尽量使用相同长度内容的值代替。 c) 尽量最小化对于含有UPDATE触发器的表的UPDATE操作。 d) 避免UPDATE将要复制到其他数据库的列。 e) 避免UPDATE建有很多索引的列。 f) 避免UPDATE在WHERE子句条件中的列。</p>
</blockquote>

<p><strong>14. 能用UNION ALL就不要用UNION</strong></p>

<blockquote>
<p>UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源 在跨多个不同的数据库时使用UNION是一个有趣的优化方法，UNION从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。 UNION ALL可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用UNION ALL更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样UNION ALL和UNION返回的结果都是一样的，但UNION ALL不会进行排序。</p>
</blockquote>

<p><strong>15. 字段数据类型优化：</strong></p>

<blockquote>
<p>a. 避免使用NULL类型：NULL对于大多数数据库都需要特殊处理，MySQL也不例外，它需要更多的代码，更多的检查和特殊的索引逻辑，有些开发人员完全没有意识到，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。 b. 尽可能使用更小的字段，MySQL从磁盘读取数据后是存储到内存中的，然后使用cpu周期和磁盘I/O读取它，这意味着越小的数据类型占用的空间越小，从磁盘读或打包到内存的效率都更好，但也不要太过执着减小数据类型，要是以后应用程序发生什么变化就没有空间了。修改表将需要重构，间接地可能引起代码的改变，这是很头疼的问题，因此需要找到一个平衡点。 c. 优先使用定长型</p>
</blockquote>

<p><strong>16. 关于大数据量limit分布的优化见下面链接（当偏移量特别大时，limit效率会非常低）：</strong></p>

<blockquote>
<p><a href="http://ariyue.iteye.com/blog/553541">http://ariyue.iteye.com/blog/553541</a>&nbsp;附上一个提高limit效率的简单技巧，在覆盖索引(覆盖索引用通俗的话讲就是在select的时候只用去读取索引而取得数据，无需进行二次select相关表)上进行偏移，而不是对全行数据进行偏移。可以将从覆盖索引上提取出来的数据和全行数据进行联接，然后取得需要的列，会更有效率，看看下面的查询： mysql&gt; select film_id, description from sakila.film order by title limit 50, 5; 如果表非常大，这个查询最好写成下面的样子： mysql&gt; select film.film_id, film.description from sakila.film inner join(select film_id from sakila.film order by title liimit 50,5) as film usinig(film_id);</p>
</blockquote>

<p><strong>17. 程序中如果一次性对同一个表插入多条数据，比如以下语句：</strong></p>

<blockquote>
<p>insert into person(name,age) values(&lsquo;xboy&rsquo;, 14); insert into person(name,age) values(&lsquo;xgirl&rsquo;, 15); insert into person(name,age) values(&lsquo;nia&rsquo;, 19); 把它拼成一条语句执行效率会更高. insert into person(name,age) values(&lsquo;xboy&rsquo;, 14), (&lsquo;xgirl&rsquo;, 15),(&lsquo;nia&rsquo;, 19);</p>
</blockquote>

<p>18.&nbsp;<strong>不要在选择的栏位上放置索引，这是无意义的。应该在条件选择的语句上合理的放置索引，比如where，order by。</strong></p>

<blockquote>
<p>SELECT id,title,content,cat_id FROM article WHERE cat_id = 1;</p>
</blockquote>

<p>上面这个语句，你在id/title/content上放置索引是毫无意义的，对这个语句没有任何优化作用。但是如果你在外键cat_id上放置一个索引，那作用就相当大了。</p>

<p>19.&nbsp;<strong>ORDER BY语句的MySQL优化：</strong>&nbsp;a. ORDER BY + LIMIT组合的索引优化。如果一个SQL语句形如：</p>

<blockquote>
<p>SELECT [column1],[column2],&hellip;. FROM [TABLE] ORDER BY [sort] LIMIT [offset],[LIMIT];</p>
</blockquote>

<p>这个SQL语句优化比较简单，在[sort]这个栏位上建立索引即可。</p>

<p>b. WHERE + ORDER BY + LIMIT组合的索引优化，形如：</p>

<blockquote>
<p>SELECT [column1],[column2],&hellip;. FROM [TABLE] WHERE [columnX] = [VALUE] ORDER BY [sort] LIMIT [offset],[LIMIT];</p>
</blockquote>

<p>这个语句，如果你仍然采用第一个例子中建立索引的方法，虽然可以用到索引，但是效率不高。更高效的方法是建立一个联合索引(columnX,sort)</p>

<p>c. WHERE + IN + ORDER BY + LIMIT组合的索引优化，形如：</p>

<blockquote>
<p>SELECT [column1],[column2],&hellip;. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],&hellip;) ORDER BY [sort] LIMIT [offset],[LIMIT];</p>
</blockquote>

<p>这个语句如果你采用第二个例子中建立索引的方法，会得不到预期的效果（仅在[sort]上是using index，WHERE那里是using where;using filesort），理由是这里对应columnX的值对应多个。 目前哥还木有找到比较优秀的办法，等待高手指教。</p>

<p>d.WHERE+ORDER BY多个栏位+LIMIT，比如:</p>

<blockquote>
<p>SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;</p>
</blockquote>

<p>对于这个语句，大家可能是加一个这样的索引:(x,y,uid)。但实际上更好的效果是(uid,x,y)。这是由MySQL处理排序的机制造成的。</p>

<p><strong>20. 其它技巧：</strong></p>

<blockquote>
<p><a href="http://www.cnblogs.com/nokiaguy/archive/2008/05/24/1206469.html">http://www.cnblogs.com/nokiaguy/archive/2008/05/24/1206469.html</a><a href="http://www.cnblogs.com/suchshow/archive/2011/12/15/2289182.html">http://www.cnblogs.com/suchshow/archive/2011/12/15/2289182.html</a><a href="http://www.cnblogs.com/cy163/archive/2009/05/28/1491473.html">http://www.cnblogs.com/cy163/archive/2009/05/28/1491473.html</a><a href="http://www.cnblogs.com/younggun/articles/1719943.html">http://www.cnblogs.com/younggun/articles/1719943.html</a><a href="http://wenku.baidu.com/view/f57c7041be1e650e52ea9985.html">http://wenku.baidu.com/view/f57c7041be1e650e52ea9985.html</a></p>
</blockquote>

<p>最后，你可以使用explain关键字去判断和评测一个sql语句是否还有优化的可能性，关于它的详细使用请参考mysql手册。</p>

<p>&nbsp;</p>

<h1><a href="http://www.cnblogs.com/ShaYeBlog/p/3227244.html" id="cb_post_title_url">关于SQL查询效率，100w数据，查询只要1秒</a></h1>

<p>1.关于SQL查询效率，100w数据，查询只要1秒，与您分享:<br />
机器情况<br />
p4: 2.4<br />
内存: 1 G<br />
os: windows 2003<br />
数据库: ms sql server 2000<br />
目的: 查询性能测试,比较两种查询的性能<br />
<br />
SQL查询效率 step by step<br />
<br />
-- setp 1.<br />
-- 建表<br />
create table t_userinfo<br />
(<br />
userid int identity(1,1) primary key nonclustered,<br />
nick varchar(50) not null default &#39;&#39;,<br />
classid int not null default 0,<br />
writetime datetime not null default getdate()<br />
)<br />
go<br />
<br />
-- 建索引<br />
create clustered index ix_userinfo_classid on t_userinfo(classid)<br />
go<br />
<br />
-- step 2.<br />
<br />
declare @i int&nbsp;<br />
declare @k int<br />
declare @nick varchar(10)<br />
set @i = 1<br />
while @i&lt;1000000<br />
begin<br />
set @k = @i % 10<br />
set @nick = convert(varchar,@i)<br />
insert into t_userinfo(nick,classid,writetime) values(@nick,@k,getdate())<br />
set @i = @i + 1<br />
end<br />
-- 耗时 08:27 ，需要耐心等待<br />
<br />
-- step 3.<br />
select top 20 userid,nick,classid,writetime from t_userinfo&nbsp;<br />
where userid not in<br />
(<br />
select top 900000 userid from t_userinfo order by userid asc<br />
)<br />
<br />
-- 耗时 8 秒 ,够长的<br />
<br />
-- step 4.<br />
select a.userid,b.nick,b.classid,b.writetime from<br />
(<br />
select top 20 a.userid from&nbsp;<br />
(<br />
select top 900020 userid from t_userinfo order by userid asc<br />
) a order by a.userid desc<br />
) a inner join t_userinfo b on a.userid = b.userid&nbsp;<br />
order by a.userid asc<br />
<br />
-- 耗时 1 秒，太快了吧，不可以思议<br />
<br />
-- step 5 where 查询<br />
select top 20 userid,nick,classid,writetime from t_userinfo&nbsp;<br />
where classid = 1 and userid not in<br />
(<br />
select top 90000 userid from t_userinfo&nbsp;<br />
where classid = 1<br />
order by userid asc<br />
)<br />
-- 耗时 2 秒<br />
<br />
-- step 6 where 查询<br />
select a.userid,b.nick,b.classid,b.writetime from<br />
(<br />
select top 20 a.userid from&nbsp;<br />
(<br />
select top 90000 userid from t_userinfo<br />
where classid = 1<br />
order by userid asc<br />
) a order by a.userid desc<br />
) a inner join t_userinfo b on a.userid = b.userid&nbsp;<br />
order by a.userid asc<br />
<br />
-- 查询分析器显示不到 1 秒.<br />
<br />
<br />
查询效率分析：<br />
子查询为确保消除重复值，必须为外部查询的每个结果都处理嵌套查询。在这种情况下可以考虑用联接查询来取代。<br />
如果要用子查询，那就用EXISTS替代IN、用NOT EXISTS替代NOT IN。因为EXISTS引入的子查询只是测试是否存在符合子查询中指定条件的行，效率较高。无论在哪种情况下,NOT IN都是最低效的。因为它对子查询中的表执行了一个全表遍历。<br />
<br />
建立合理的索引,避免扫描多余数据，避免表扫描！<br />
几百万条数据，照样几十毫秒完成查询.<br />
2.&nbsp;<br />
SQL提高查询效率<br />
2008-05-12 21:20<br />
1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&nbsp;<br />
<br />
2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：&nbsp;<br />
select id from t where num is null&nbsp;<br />
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：&nbsp;<br />
select id from t where num=0&nbsp;<br />
<br />
3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。&nbsp;<br />
<br />
4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：&nbsp;<br />
select id from t where num=10 or num=20&nbsp;<br />
可以这样查询：&nbsp;<br />
select id from t where num=10&nbsp;<br />
union all&nbsp;<br />
select id from t where num=20&nbsp;<br />
<br />
5.in 和 not in 也要慎用，否则会导致全表扫描，如：&nbsp;<br />
select id from t where num in(1,2,3)&nbsp;<br />
对于连续的数值，能用 between 就不要用 in 了：&nbsp;<br />
select id from t where num between 1 and 3&nbsp;<br />
<br />
6.下面的查询也将导致全表扫描：&nbsp;<br />
select id from t where name like &#39;%abc%&#39;&nbsp;<br />
若要提高效率，可以考虑全文检索。&nbsp;<br />
<br />
7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：&nbsp;<br />
select id from t where num=@num&nbsp;<br />
可以改为强制查询使用索引：&nbsp;<br />
select id from t with(index(索引名)) where num=@num&nbsp;<br />
<br />
8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：&nbsp;<br />
select id from t where num/2=100&nbsp;<br />
应改为:&nbsp;<br />
select id from t where num=100*2&nbsp;<br />
<br />
9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：&nbsp;<br />
select id from t where substring(name,1,3)=&#39;abc&#39;--name以abc开头的id&nbsp;<br />
select id from t where datediff(day,createdate,&#39;2005-11-30&#39;)=0--&lsquo;2005-11-30&rsquo;生成的id&nbsp;<br />
应改为:&nbsp;<br />
select id from t where name like &#39;abc%&#39;&nbsp;<br />
select id from t where createdate&gt;=&#39;2005-11-30&#39; and createdate&lt;&#39;2005-12-1&#39;&nbsp;<br />
<br />
10.不要在 where 子句中的&ldquo;=&rdquo;左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。&nbsp;<br />
<br />
11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。&nbsp;<br />
<br />
12.不要写一些没有意义的查询，如需要生成一个空表结构：&nbsp;<br />
select col1,col2 into #t from t where 1=0&nbsp;<br />
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：&nbsp;<br />
create table #t(...)&nbsp;<br />
<br />
13.很多时候用 exists 代替 in 是一个好的选择：&nbsp;<br />
select num from a where num in(select num from b)&nbsp;<br />
用下面的语句替换：&nbsp;<br />
select num from a where exists(select 1 from b where num=a.num)&nbsp;<br />
<br />
14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。&nbsp;<br />
<br />
15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。&nbsp;<br />
<br />
16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。&nbsp;<br />
<br />
17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。&nbsp;<br />
<br />
18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&nbsp;<br />
<br />
19.任何地方都不要使用 select * from t ，用具体的字段列表代替&ldquo;*&rdquo;，不要返回用不到的任何字段。&nbsp;<br />
<br />
20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。&nbsp;<br />
<br />
21.避免频繁创建和删除临时表，以减少系统表资源的消耗。&nbsp;<br />
<br />
22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。&nbsp;<br />
<br />
23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。&nbsp;<br />
<br />
24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。&nbsp;<br />
<br />
25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。&nbsp;<br />
<br />
26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。&nbsp;<br />
<br />
27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括&ldquo;合计&rdquo;的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。&nbsp;<br />
<br />
28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。&nbsp;<br />
<br />
29.尽量避免大事务操作，提高系统并发能力。&nbsp;<br />
<br />
30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理<br />
<br />
1、避免将字段设为&ldquo;允许为空&rdquo;<br />
2、数据表设计要规范<br />
3、深入分析数据操作所要对数据库进行的操作<br />
4、尽量不要使用临时表<br />
5、多多使用事务<br />
6、尽量不要使用游标<br />
7、避免死锁<br />
8、要注意读写锁的使用<br />
9、不要打开大的数据集<br />
10、不要使用服务器端游标<br />
11、在程序编码时使用大数据量的数据库<br />
12、不要给&ldquo;性别&rdquo;列创建索引<br />
13、注意超时问题<br />
14、不要使用Select *<br />
15、在细节表中插入纪录时，不要在主表执行Select MAX(ID)<br />
16、尽量不要使用TEXT数据类型<br />
17、使用参数查询<br />
18、不要使用Insert导入大批的数据<br />
19、学会分析查询<br />
20、使用参照完整性<br />
21、用INNER JOIN 和LEFT JOIN代替Where&nbsp;<br />
<br />
<br />
提高SQL查询效率（要点与技巧）：<br />
&middot; 技巧一：<br />
问题类型：ACCESS数据库字段中含有日文片假名或其它不明字符时查询会提示内存溢出。<br />
解决方法：修改查询语句<br />
sql=&quot;select * from tablename where column like &#39;%&quot;&amp;word&amp;&quot;%&#39;&quot;<br />
改为<br />
sql=&quot;select * from tablename&quot;<br />
rs.filter = &quot; column like &#39;%&quot;&amp;word&amp;&quot;%&#39;&quot;<br />
===========================================================<br />
技巧二：<br />
问题类型：如何用简易的办法实现类似百度的多关键词查询（多关键词用空格或其它符号间隔）。<br />
解决方法：<br />
&#39;//用空格分割查询字符串<br />
ck=split(word,&quot; &quot;)<br />
&#39;//得到分割后的数量<br />
sck=UBound(ck)<br />
sql=&quot;select * tablename where&quot;<br />
在一个字段中查询<br />
For i = 0 To sck<br />
SQL = SQL &amp; tempJoinWord &amp; &quot;(&quot; &amp; _<br />
&quot;column like &#39;&quot;&amp;ck(i)&amp;&quot;%&#39;)&quot;<br />
tempJoinWord = &quot; and &quot;<br />
Next<br />
在二个字段中同时查询<br />
For i = 0 To sck<br />
SQL = SQL &amp; tempJoinWord &amp; &quot;(&quot; &amp; _<br />
&quot;column like &#39;&quot;&amp;ck(i)&amp;&quot;%&#39; or &quot; &amp; _<br />
&quot;column1 like &#39;&quot;&amp;ck(i)&amp;&quot;%&#39;)&quot;<br />
tempJoinWord = &quot; and &quot;<br />
Next<br />
===========================================================<br />
技巧三：大大提高查询效率的几种技巧<br />
<br />
1. 尽量不要使用 or，使用or会引起全表扫描，将大大降低查询效率。<br />
2. 经过实践验证，charindex()并不比前面加%的like更能提高查询效率，并且charindex()会使索引失去作用（指sqlserver数据库）<br />
3. column like &#39;%&quot;&amp;word&amp;&quot;%&#39; 会使索引不起作用<br />
column like &#39;&quot;&amp;word&amp;&quot;%&#39; 会使索引起作用（去掉前面的%符号）<br />
（指sqlserver数据库）<br />
4. &#39;%&quot;&amp;word&amp;&quot;%&#39; 与&#39;&quot;&amp;word&amp;&quot;%&#39; 在查询时的区别：<br />
比如你的字段内容为 一个容易受伤的女人<br />
&#39;%&quot;&amp;word&amp;&quot;%&#39; ：会通配所有字符串，不论查&ldquo;受伤&rdquo;还是查&ldquo;一个&rdquo;，都会显示结果。<br />
&#39;&quot;&amp;word&amp;&quot;%&#39; ：只通配前面的字符串，例如查&ldquo;受伤&rdquo;是没有结果的，只有查&ldquo;一个&rdquo;，才会显示结果。<br />
5. 字段提取要按照&ldquo;需多少、提多少&rdquo;的原则，避免&ldquo;select *&rdquo;，尽量使用&ldquo;select 字段1,字段2,字段3........&rdquo;。实践证明：每少提取一个字段，数据的提取速度就会有相应的提升。提升的速度还要看您舍弃的字段的大小来判断。<br />
6. order by按聚集索引列排序效率最高。一个sqlserver数据表只能建立一个聚集索引，一般默认为ID，也可以改为其它的字段。<br />
7. 为你的表建立适当的索引，建立索引可以使你的查询速度提高几十几百倍。（指sqlserver数据库）<br />
&middot; 以下是建立索引与不建立索引的一个查询效率分析：<br />
Sqlserver索引与查询效率分析。<br />
表 News<br />
字段<br />
Id：自动编号<br />
Title：文章标题<br />
Author：作者<br />
Content：内容<br />
Star：优先级<br />
Addtime：时间<br />
记录：100万条<br />
测试机器：P4 2.8/1G内存/IDE硬盘<br />
=======================================================<br />
方案1：<br />
主键Id，默认为聚集索引，不建立其它非聚集索引<br />
select * from News where Title like &#39;%&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;%&quot;&amp;word&amp;&quot;%&#39; order by Id desc<br />
从字段Title和Author中模糊检索，按Id排序<br />
查询时间：50秒<br />
=======================================================<br />
方案2：<br />
主键Id，默认为聚集索引<br />
在Title、Author、Star上建立非聚集索引<br />
select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39; order by Id desc<br />
从字段Title和Author中模糊检索，按Id排序<br />
查询时间：2 - 2.5秒<br />
=======================================================<br />
方案3：<br />
主键Id，默认为聚集索引<br />
在Title、Author、Star上建立非聚集索引<br />
select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39; order by Star desc<br />
从字段Title和Author中模糊检索，按Star排序<br />
查询时间：2 秒<br />
=======================================================<br />
方案4：<br />
主键Id，默认为聚集索引<br />
在Title、Author、Star上建立非聚集索引<br />
select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39;<br />
从字段Title和Author中模糊检索，不排序<br />
查询时间：1.8 - 2 秒<br />
=======================================================<br />
方案5：<br />
主键Id，默认为聚集索引<br />
在Title、Author、Star上建立非聚集索引<br />
select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39;<br />
或<br />
select * from News where Author like &#39;&quot;&amp;word&amp;&quot;%&#39;<br />
从字段Title 或 Author中检索，不排序<br />
查询时间：1秒<br />
&middot; 如何提高SQL语言的查询效率?<br />
问：请问我如何才能提高SQL语言的查询效率呢？<br />
答：这得从头说起：<br />
&nbsp;&nbsp; 由于SQL是面向结果而不是面向过程的查询语言，所以一般支持SQL语言的大型关系型数据库都使用一个基于查询成本的优化器，为即时查询提供一个最佳的执行策略。对于优化器，输入是一条查询语句，输出是一个执行策略。<br />
&nbsp;&nbsp;&nbsp; 一条SQL查询语句可以有多种执行策略，优化器将估计出全部执行方法中所需时间最少的所谓成本最低的那一种方法。所有优化都是基于用记所使用的查询语句中的where子句，优化器对where子句中的优化主要用搜索参数(Serach Argument)。<br />
&nbsp;&nbsp;&nbsp; 搜索参数的核心思想就是数据库使用表中字段的索引来查询数据，而不必直接查询记录中的数据。<br />
&nbsp;&nbsp;&nbsp; 带有 =、&lt;、&lt;=、&gt;、&gt;= 等操作符的条件语句可以直接使用索引，如下列是搜索参数：<br />
&nbsp;&nbsp;&nbsp; emp_id = &quot;10001&quot; 或 salary &gt; 3000 或&nbsp; a =1 and c = 7<br />
&nbsp;&nbsp;&nbsp; 而下列则不是搜索参数：<br />
&nbsp;&nbsp;&nbsp; salary = emp_salary 或 dep_id != 10 或 salary * 12 &gt;= 3000 或 a=1 or c=7<br />
&nbsp;&nbsp;&nbsp; 应当尽可能提供一些冗余的搜索参数，使优化器有更多的选择余地。请看以下3种方法：<br />
&nbsp;&nbsp;&nbsp; 第一种方法：<br />
&nbsp;&nbsp;&nbsp; select employee.emp_name,department.dep_name from department,employee where (employee.dep_id = department.dep_id) and (department.dep_code=&quot;01&quot;) and (employee.dep_code=&quot;01&quot;);<br />
&nbsp;&nbsp;&nbsp; 它的搜索分析结果如下：<br />
&nbsp;&nbsp;&nbsp; Estimate 2 I/O operations<br />
&nbsp;&nbsp;&nbsp; Scan department using primary key<br />
&nbsp;&nbsp;&nbsp; for rows where dep_code equals &quot;01&quot;<br />
&nbsp;&nbsp;&nbsp; Estimate getting here 1 times<br />
&nbsp;&nbsp;&nbsp; Scan employee sequentially<br />
&nbsp;&nbsp;&nbsp; Estimate getting here 5 times<br />
&nbsp;&nbsp;&nbsp; 第二种方法：<br />
&nbsp;&nbsp;&nbsp; select employee.emp_name,department.dep_name from department,employee where (employee.dep_id = department.dep_id) and (department.dep_code=&quot;01&quot;);<br />
&nbsp;&nbsp;&nbsp; 它的搜索分析结果如下：<br />
&nbsp;&nbsp;&nbsp; Estimate 2 I/O operations<br />
&nbsp;&nbsp;&nbsp; Scan department using primary key<br />
&nbsp;&nbsp;&nbsp; for rows where dep_code equals &quot;01&quot;<br />
&nbsp;&nbsp;&nbsp; Estimate getting here 1 times<br />
&nbsp;&nbsp;&nbsp; Scan employee sequentially<br />
&nbsp;&nbsp;&nbsp; Estimate getting here 5 times<br />
&nbsp;&nbsp;&nbsp; 第一种方法与第二种运行效率相同，但第一种方法最好，因为它为优化器提供了更多的选择机会。<br />
&nbsp;&nbsp;&nbsp; 第三种方法：<br />
&nbsp;&nbsp;&nbsp; select employee.emp_name,department.dep_name from department,employee where (employee.dep_id = department.dep_id) and (employee.dep_code=&quot;01&quot;);<br />
&nbsp;&nbsp;&nbsp; 这种方法最不好，因为它无法使用索引，也就是无法优化&hellip;&hellip;<br />
使用SQL语句时应注意以下几点：<br />
&nbsp;&nbsp;&nbsp; 1、避免使用不兼容的数据类型。例如，Float和Integer，Char和Varchar，Binary和Long Binary不兼容的。数据类型的不兼容可能使优化器无法执行一些本可以进行的优化操作。例如：<br />
&nbsp;&nbsp;&nbsp; select emp_name form employee where salary &gt; 3000;<br />
&nbsp;&nbsp;&nbsp; 在此语句中若salary是Float类型的，则优化器很难对其进行优化，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。<br />
&nbsp;&nbsp;&nbsp; 2、尽量不要使用表达式，因它在编绎时是无法得到的，所以SQL只能使用其平均密度来估计将要命中的记录数。<br />
&nbsp;&nbsp;&nbsp; 3、避免对搜索参数使用其他的数学操作符。如：<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select emp_name from employee where salary * 12 &gt; 3000;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 应改为：<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select emp_name from employee where salary&nbsp; &gt; 250;<br />
&nbsp;&nbsp;&nbsp; 4、避免使用 != 或 &lt;&gt; 等这样的操作符，因为它会使系统无法使用索引，而只能直接搜索表中的数据。<br />
&middot; ORACAL中的应用<br />
一个1600万数据表－－短信上行表TBL_SMS_MO<br />
结构：<br />
CREATE TABLE TBL_SMS_MO<br />
(<br />
SMS_ID NUMBER,<br />
MO_ID VARCHAR2(50),<br />
MOBILE VARCHAR2(11),<br />
SPNUMBER VARCHAR2(20),<br />
MESSAGE VARCHAR2(150),<br />
TRADE_CODE VARCHAR2(20),<br />
LINK_ID VARCHAR2(50),<br />
GATEWAY_ID NUMBER,<br />
GATEWAY_PORT NUMBER,<br />
MO_TIME DATE DEFAULT SYSDATE<br />
);<br />
CREATE INDEX IDX_MO_DATE ON TBL_SMS_MO (MO_TIME)<br />
&nbsp; PCTFREE 10<br />
&nbsp; INITRANS 2<br />
&nbsp; MAXTRANS 255<br />
&nbsp; STORAGE<br />
&nbsp; (<br />
&nbsp;&nbsp;&nbsp; INITIAL 1M<br />
&nbsp;&nbsp;&nbsp; NEXT 1M<br />
&nbsp;&nbsp;&nbsp; MINEXTENTS 1<br />
&nbsp;&nbsp;&nbsp; MAXEXTENTS UNLIMITED<br />
&nbsp;&nbsp;&nbsp; PCTINCREASE 0<br />
&nbsp; );<br />
CREATE INDEX IDX_MO_MOBILE ON TBL_SMS_MO (MOBILE)<br />
&nbsp; PCTFREE 10<br />
&nbsp; INITRANS 2<br />
&nbsp; MAXTRANS 255<br />
&nbsp; STORAGE<br />
&nbsp; (<br />
&nbsp;&nbsp;&nbsp; INITIAL 64K<br />
&nbsp;&nbsp;&nbsp; NEXT 1M<br />
&nbsp;&nbsp;&nbsp; MINEXTENTS 1<br />
&nbsp;&nbsp;&nbsp; MAXEXTENTS UNLIMITED<br />
&nbsp;&nbsp;&nbsp; PCTINCREASE 0<br />
&nbsp; );<br />
&nbsp; 问题：从表中查询某时间段内某手机发送的短消息，如下SQL语句：<br />
SELECT MOBILE,MESSAGE,TRADE_CODE,MO_TIME<br />
FROM TBL_SMS_MO<br />
WHERE MOBILE=&#39;130XXXXXXXX&#39;<br />
AND MO_TIME BETWEEN TO_DATE(&#39;2006-04-01&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;) AND TO_DATE(&#39;2006-04-07&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;)<br />
ORDER BY MO_TIME DESC<br />
返回结果大约需要10分钟，应用于网页查询，简直难以忍受。<br />
分析：<br />
在PL/SQL Developer，点击&ldquo;Explain Plan&rdquo;按钮（或F5键），对SQL进行分析，发现缺省使用的索引是IDX_MO_DATE。问题可能出在这里，因为相对于总数量1600万数据来说，都mobile的数据是很少的，如果使用IDX_MO_MOBILE比较容易锁定数据。<br />
如下优化：<br />
SELECT /*+ index(TBL_SMS_MO IDX_MO_MOBILE) */ MOBILE,MESSAGE,TRADE_CODE,MO_TIME<br />
FROM TBL_SMS_MO<br />
WHERE MOBILE=&#39;130XXXXXXXX&#39;<br />
AND MO_TIME BETWEEN TO_DATE(&#39;2006-04-01&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;) AND TO_DATE(&#39;2006-04-07&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;)<br />
ORDER BY MO_TIME DESC<br />
测试：<br />
按F8运行这个SQL，哇～... ... 2.360s，这就是差别。</p>
