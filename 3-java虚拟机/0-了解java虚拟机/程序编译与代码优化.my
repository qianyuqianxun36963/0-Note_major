<h1>第四部分 程序编译与代码优化</h1>

<h2>第10章 早期（编译期）优化</h2>

<p>从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如<br />
一场没有终点、 永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛<br />
车。</p>

<h3>10.1 概述</h3>

<p>Java语言的&ldquo;编译期&rdquo;其实是一段&ldquo;不确定&rdquo;的操作过程，因为它可能是指一个前端编译器<br />
（其实叫&ldquo;编译器的前端&rdquo;更准确一些）把*.java文件转变成*.class文件的过程；也可能是指虚<br />
拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过<br />
程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把*.java<br />
文件编译成本地机器代码的过程。 下面列举了这3类编译过程中一些比较有代表性的编译<br />
器。<br />
前端编译器：Sun的Javac、 Eclipse JDT中的增量式编译器（ECJ）[1]。<br />
JIT编译器：HotSpot VM的C1、 C2编译器。<br />
AOT编译器：GNU Compiler for the Java（GCJ）[2]、 Excelsior JET[3]。<br />
这3类过程中最符合大家对Java程序编译认知的应该是第一类，在本章的后续文字里，<br />
笔者提到的&ldquo;编译期&rdquo;和&ldquo;编译器&rdquo;都仅限于第一类编译过程，把第二类编译过程留到下一章中<br />
讨论。 限制了编译范围后，我们对于&ldquo;优化&rdquo;二字的定义就需要宽松一些，因为Javac这类编译<br />
器对代码的运行效率几乎没有任何优化措施（在JDK 1.3之后，Javac的-O优化参数就不再有<br />
意义）。 虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不<br />
是由Javac产生的Class文件（如JRuby、 Groovy等语言的Class文件）也同样能享受到编译器优<br />
化所带来的好处。 但是Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码<br />
风格和提高编码效率。 相当多新生的Java语法特性，都是靠编译器的&ldquo;语法糖&rdquo;来实现，而不<br />
是依赖虚拟机的底层改进来支持，可以说，Java中即时编译器在运行期的优化过程对于程序<br />
运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。<br />
[1]JDT官方站点：http://www.eclipse.org/jdt/。<br />
[2]GCJ官方站点：http://gcc.gnu.org/java/。<br />
[3]Excelsior JET官方站点：http://www.excelsior-usa.com/。<br />
10.2 Javac编译器<br />
分析源码是了解一项技术的实现内幕最有效的手段，Javac编译器不像HotSpot虚拟机那<br />
样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯<br />
Java的程序员了解它的编译过程带来了很大的便利。<br />
10.2.1 Javac的源码与调试<br />
Javac的源码存放在JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac中[1]，<br />
除了JDK自身的API外，就只引用了JDK_SRC_HOME/langtools/src/share/classes/com/sun/*里面<br />
的代码，调试环境建立起来简单方便，因为基本上不需要处理依赖关系。<br />
以Eclipse IDE环境为例，先建立一个名为&ldquo;Compiler_javac&rdquo;的Java工程，然后把<br />
JDK_SRC_HOME/langtools/src/share/classes/com/sun/*目录下的源文件全部复制到工程的源码<br />
目录中，如图10-1所示。<br />
图 10-1 Eclipse中的Javac工程<br />
导入代码期间，源码文件&ldquo;AnnotationProxy Maker.java&rdquo;可能会提示&ldquo;Access Restriction&rdquo;，<br />
被Eclipse拒绝编译，如图10-2所示。<br />
图 10-2 AnnotationProxyMaker被拒绝编译<br />
这是由于Eclipse的JRE System Library中默认包含了一系列的代码访问规则（Access<br />
Rules），如果代码中引用了这些访问规则所禁止引用的类，就会提示这个错误。 可以通过<br />
添加一条允许访问JAR包中所有类的访问规则来解决这个问题，如图10-3所示。<br />
图 10-3 设置访问规则<br />
导入了Javac的源码后，就可以运行com.sun.tools.javac.Main的main（）方法来执行编译<br />
了，与命令行中使用Javac的命令没有什么区别，编译的文件与参数在Eclipse的&ldquo;Debug<br />
Configurations&rdquo;面板中的&ldquo;Arguments&rdquo;页签中指定。<br />
虚拟机规范严格定义了Class文件的格式，但是《 Java虚拟机规范（第2版）》 中，虽然<br />
有专门的一章&ldquo;Compiling for the Java Virtual Machine&rdquo;，但都是以举例的形式描述，并没有对<br />
如何把Java源码文件转变为Class文件的编译过程进行十分严格的定义，这导致Class文件编译<br />
在某种程度上是与具体JDK实现相关的，在一些极端情况，可能出现一段代码Javac编译器可<br />
以编译，但是ECJ编译器就不可以编译的问题（10.3.1节中将会给出这样的例子）。 从Sun<br />
Javac的代码来看，编译过程大致可以分为3个过程，分别是：<br />
解析与填充符号表过程。<br />
插入式注解处理器的注解处理过程。<br />
分析与字节码生成过程。<br />
这3个步骤之间的关系与交互顺序如图10-4所示。<br />
图 10-4 Javac的编译过程[2]<br />
Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻<br />
辑集中在这个类的compile（）和compile2（）方法中，其中主体代码如图10-5所示，整个编<br />
译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么<br />
功能。<br />
图 10-5 Javac编译过程的主体代码<br />
[1]关于如何获取OpenJDK源码，请参考本书第1章。<br />
[2]图片来源：http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html，本书<br />
对相关术语进行了翻译。<br />
10.2.2 解析与填充符号表<br />
解析步骤由图10-5中的parseFiles（）方法（图10-5中的过程1.1）完成，解析步骤包括了<br />
经典程序编译原理中的词法分析和语法分析两个过程。<br />
1.词法、 语法分析<br />
词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的<br />
最小元素，而标记则是编译过程的最小元素，关键字、 变量名、 字面量、 运算符都可以成为<br />
标记，如&ldquo;int a=b+2&rdquo;这句代码包含了6个标记，分别是int、 a、 =、 b、 +、 2，虽然关键字int由<br />
3个字符构成，但是它只是一个Token，不可再拆分。 在Javac的源码中，词法分析过程由<br />
com.sun.tools.javac.parser.Scanner类来实现。<br />
语法分析是根据Token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax<br />
Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表<br />
着程序代码中的一个语法结构（Construct），例如包、 类型、 修饰符、 运算符、 接口、 返回<br />
值甚至代码注释等都可以是一个语法结构。<br />
图10-6是根据Eclipse AST View插件分析出来的某段代码的抽象语法树视图，读者可以<br />
通过这张图对抽象语法树有一个直观的认识。 在Javac的源码中，语法分析过程由<br />
com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由<br />
com.sun.tools.javac.tree.JCTree类表示，经过这个步骤之后，编译器就基本不会再对源码文件<br />
进行操作了，后续的操作都建立在抽象语法树之上。<br />
图 10-6 抽象语法树结构视图<br />
2.填充符号表<br />
完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是图10-5中<br />
enterTrees（）方法（图10-5中的过程1.2）所做的事情。 符号表（Symbol Table）是由一组符<br />
号地址和符号信息构成的表格，读者可以把它想象成哈希表中K-V值对的形式（实际上符号<br />
表不一定是哈希表实现，可以是有序符号表、 树状符号表、 栈结构符号表等）。 符号表中所<br />
登记的信息在编译的不同阶段都要用到。 在语义分析中，符号表所登记的内容将用于语义检<br />
查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。 在目标代码生成阶<br />
段，当对符号名进行地址分配时，符号表是地址分配的依据。<br />
在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的<br />
出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，<br />
以及package-info.java（如果存在的话）的顶级节点。<br />
10.2.3 注解处理器<br />
在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代<br />
码一样，是在运行期间发挥作用的。 在JDK 1.6中实现了JSR-269规范[1]，提供了一组插入式<br />
注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插<br />
件，在这些插件里面，可以读取、 修改、 添加抽象语法树中的任意元素。 如果这些插件在处<br />
理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所<br />
有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是<br />
图10-4中的回环过程。<br />
有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法<br />
树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器<br />
实现的插件在功能上有很大的发挥空间。 只要有足够的创意，程序员可以使用插入式注解处<br />
理器来实现许多原本只能在编码中完成的事情，本章最后会给出一个使用插入式注解处理器<br />
的简单实战。<br />
在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations（）方法中<br />
完成的，而它的执行过程则是在processAnnotations（）方法中完成的，这个方法判断是否还<br />
有新的注解处理器需要执行，如果有的话，通过<br />
com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个<br />
新的JavaCompiler对象对编译的后续步骤进行处理。<br />
[1]JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。<br />
10.2.4 语义分析与字节码生成<br />
语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确<br />
的源程序的抽象，但无法保证源程序是符合逻辑的。 而语义分析的主要任务是对结构上正确<br />
的源程序进行上下文有关性质的审查，如进行类型审查。 举个例子，假设有如下的3个变量<br />
定义语句：<br />
int a=1；<br />
boolean b=false；<br />
char c=2；<br />
后续可能出现的赋值运算：<br />
int d=a+c；<br />
int d=b+c；<br />
char d=a+c；<br />
后续代码中如果出现了如上3种赋值运算的话，那它们都能构成结构正确的语法树，但<br />
是只有第1种的写法在语义上是没有问题的，能够通过编译，其余两种在Java语言中是不合<br />
逻辑的，无法编译（是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有<br />
意义。 如在C语言中，a、 b、 c的上下文定义不变，第2、 3种写法都是可以正确编译）。<br />
1.标注检查<br />
Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分<br />
别由图10-5中所示的attribute（）和flow（）方法（分别对应图10-5中的过程3.1和过程3.2）<br />
完成。<br />
标注检查步骤检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类<br />
型是否能够匹配等。 在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代<br />
码中写了如下定义：<br />
int a=1+2；<br />
那么在语法树上仍然能看到字面量&ldquo;1&rdquo;、 &ldquo;2&rdquo;以及操作符&ldquo;+&rdquo;，但是在经过常量折叠之<br />
后，它们将会被折叠为字面量&ldquo;3&rdquo;，如图10-7所示，这个插入式表达式（Infix Expression）的<br />
值已经在语法树上标注出来了（ConstantExpressionValue：3）。 由于编译期间进行了常量折<br />
叠，所以在代码里面定义&ldquo;a=1+2&rdquo;比起直接定义&ldquo;a=3&rdquo;，并不会增加程序运行期哪怕仅仅一个<br />
CPU指令的运算量。<br />
图 10-7 常量折叠<br />
标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和<br />
com.sun.tools.javac.comp.Check类。<br />
2.数据及控制流分析<br />
数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变<br />
量在使用前是否有赋值、 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处<br />
理了等问题。 编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是<br />
一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。 下面举一个<br />
关于final修饰符的数据及控制流分析的例子，见代码清单10-1。<br />
代码清单10-1 final语义校验<br />
//方法一带有final修饰<br />
public void foo（final int arg）{<br />
final int var=0；<br />
//do something<br />
}/<br />
/方法二没有final修饰<br />
public void foo（int arg）{<br />
int var=0；<br />
//do something<br />
} 在<br />
这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二<br />
种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量<br />
的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，通过第6章的讲解我们<br />
已经知道，局部变量与字段（实例变量、 类变量）是有区别的，它在常量池中没有<br />
CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至<br />
可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局<br />
部变量是不是声明为final了。 因此，将局部变量声明为final，对运行期是没有影响的，变量<br />
的不变性仅仅由编译器在编译期间保障。 在Javac的源码中，数据及控制流分析的入口是图<br />
10-5中的flow（）方法（对应图10-5中的过程3.2），具体操作由<br />
com.sun.tools.javac.comp.Flow类来完成。<br />
3.解语法糖<br />
语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机科学家彼得&middot;约翰&middot;兰达<br />
（Peter J.Landin）发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的<br />
功能并没有影响，但是更方便程序员使用。 通常来说，使用语法糖能够增加程序的可读性，<br />
从而减少程序代码出错的机会。<br />
Java在现代编程语言之中属于&ldquo;低糖语言&rdquo;（相对于C#及许多其他JVM语言来说），尤其<br />
是JDK 1.5之前的版本，&ldquo;低糖&rdquo;语法也是Java语言被怀疑已经&ldquo;落后&rdquo;的一个表面理由。 Java中<br />
最常用的语法糖主要是前面提到过的泛型（泛型并不一定都是语法糖实现，如C#的泛型就是<br />
直接由CLR支持的）、 变长参数、 自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在<br />
编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。 Java的这些语法糖被解除后<br />
是什么样子，将在10.3节中详细讲述。<br />
在Javac的源码中，解语法糖的过程由desugar（）方法触发，在<br />
com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。<br />
4.字节码生成<br />
字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由<br />
com.sun.tools.javac.jvm.Gen类来完成。 字节码生成阶段不仅仅是把前面各个步骤所生成的信<br />
息（语法树、 符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工<br />
作。<br />
例如，前面章节中多次提到的实例构造器＜init＞（）方法和类构造器＜clinit＞（）方<br />
法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，<br />
如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、 访问性<br />
（public、 protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就<br />
已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块<br />
（对于实例构造器而言是&ldquo;{}&rdquo;块，对于类构造器而言是&ldquo;static{}&rdquo;块）、 变量初始化（实例变<br />
量和类变量）、 调用父类的实例构造器（仅仅是实例构造器，＜clinit＞（）方法中无须调用<br />
父类的＜clinit＞（）方法，虚拟机会自动保证父类构造器的执行，但在＜clinit＞（）方法中<br />
经常会生成调用java.lang.Object的＜init＞（）方法的代码）等操作收敛到＜init＞（）和＜<br />
clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后<br />
执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。 除了生成构<br />
造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替<br />
换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 1.5）的<br />
append（）操作等。<br />
完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给<br />
com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终<br />
的Class文件，到此为止整个编译过程宣告结束。<br />
10.3 Java语法糖的味道<br />
几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然<br />
不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编<br />
码出错的机会。 不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用&ldquo;含<br />
糖&rdquo;的语法，容易让程序员产生依赖，无法看清语法糖的糖衣背后，程序代码的真实面目。<br />
总而言之，语法糖可以看做是编译器实现的一些&ldquo;小把戏&rdquo;，这些&ldquo;小把戏&rdquo;可能会使得效<br />
率&ldquo;大提升&rdquo;，但我们也应该去了解这些&ldquo;小把戏&rdquo;背后的真实世界，那样才能利用好它们，而<br />
不是被它们所迷惑。<br />
10.3.1 泛型与类型擦除<br />
泛型是JDK 1.5的一项新增特性，它的本质是参数化类型（Parametersized Type）的应<br />
用，也就是说所操作的数据类型被指定为一个参数。 这种参数类型可以用在类、 接口和方法<br />
的创建中，分别称为泛型类、 泛型接口和泛型方法。<br />
泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有<br />
出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实<br />
现类型泛化。 例如，在哈希表的存取中，JDK 1.5之前使用HashMap的get（）方法，返回值<br />
就是一个Object对象，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转<br />
型成任何对象都是有可能的。 但是也因为有无限的可能性，就只有程序员和运行期的虚拟机<br />
才知道这个Object到底是个什么类型的对象。 在编译期间，编译器无法检查这个Object的强<br />
制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的<br />
风险就会转嫁到程序运行期之中。<br />
泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面<br />
泛型无论在程序源码中、 编译后的IL中（Intermediate Language，中间语言，这时候泛型是一<br />
个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不<br />
同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨<br />
胀，基于这种方法实现的泛型称为真实泛型。<br />
Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已<br />
经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转<br />
型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一<br />
个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型<br />
擦除，基于这种方法实现的泛型称为伪泛型。<br />
代码清单10-2是一段简单的Java泛型的例子，我们可以看一下它编译后的结果是怎样<br />
的。<br />
代码清单10-2 泛型擦除前的例子<br />
public static void main（String[]args）{<br />
Map＜String,String＞map=new HashMap＜String,String＞（）；<br />
map.put（&quot;hello&quot;，&quot;你好&quot;）；<br />
map.put（&quot;how are you?&quot;，&quot;吃了没？&quot;）；<br />
System.out.println（map.get（&quot;hello&quot;））；<br />
System.out.println（map.get（&quot;how are you?&quot;））；<br />
}<br />
把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现<br />
泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型，如代<br />
码清单10-3所示。<br />
代码清单10-3 泛型擦除后的例子<br />
public static void main（String[]args）{<br />
Map map=new HashMap（）；<br />
map.put（&quot;hello&quot;，&quot;你好&quot;）；<br />
map.put（&quot;how are you?&quot;，&quot;吃了没？&quot;）；<br />
System.out.println（（String）map.get（&quot;hello&quot;））；<br />
System.out.println（（String）map.get（&quot;how are you?&quot;））；<br />
} 当<br />
初JDK设计团队为什么选择类型擦除的方式来实现Java语言的泛型支持呢？是因为实<br />
现简单、 兼容性考虑还是别的原因？我们已不得而知，但确实有不少人对Java语言提供的伪<br />
泛型颇有微词，当时甚至连《 Thinking in Java》 一书的作者Bruce Eckel也发表了一篇文章<br />
《 这不是泛型！》 [1]来批评JDK 1.5中的泛型实现。<br />
在当时众多的批评之中，有一些是比较表面的，还有一些从性能上说泛型会由于强制转<br />
型操作和运行期缺少针对类型的优化等从而导致比C#的泛型慢一些，则是完全偏离了方向，<br />
姑且不论Java泛型是不是真的会比C#泛型慢，选择从性能的角度上评价用于提升语义准确性<br />
的泛型思想就不太恰当。 但笔者也并非在为Java的泛型辩护，它在某些场景下确实存在不<br />
足，笔者认为通过擦除法来实现泛型丧失了一些泛型思想应有的优雅，例如代码清单10-4的<br />
例子。<br />
代码清单10-4 当泛型遇见重载1<br />
public class GenericTypes{<br />
public static void method（List＜String＞list）{<br />
System.out.println（&quot;invoke method（List＜String＞list）&quot;）；<br />
}p<br />
ublic static void method（List＜Integer＞list）{<br />
System.out.println（&quot;invoke method（List＜Integer＞list）&quot;）；<br />
}} 请<br />
想一想，上面这段代码是否正确，能否编译执行？也许你已经有了答案，这段代码是<br />
不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的<br />
原生类型List＜E＞，擦除动作导致这两种方法的特征签名变得一模一样。 初步看来，无法重<br />
载的原因已经找到了，但真的就是如此吗？只能说，泛型擦除成相同的原生类型只是无法重<br />
载的其中一部分原因，请再接着看一看代码清单10-5中的内容。<br />
代码清单10-5 当泛型遇见重载2<br />
public class GenericTypes{<br />
public static String method（List＜String＞list）{<br />
System.out.println（&quot;invoke method（List＜String＞list）&quot;）；<br />
return&quot;&quot;；<br />
}p<br />
ublic static int method（List＜Integer＞list）{<br />
System.out.println（&quot;invoke method（List＜Integer＞list）&quot;）；<br />
return 1；<br />
}p<br />
ublic static void main（String[]args）{<br />
method（new ArrayList＜String＞（））；<br />
method（new ArrayList＜Integer＞（））；<br />
}}<br />
执行结果：<br />
invoke method（List＜String＞list）<br />
invoke method（List＜Integer＞list）<br />
代码清单10-5与代码清单10-4的差别是两个method方法添加了不同的返回值，由于这两<br />
个返回值的加入，方法重载居然成功了，即这段代码可以被编译和执行[2]了。 这是对Java语<br />
言中返回值不参与重载选择的基本认知的挑战吗？<br />
代码清单10-5中的重载当然不是根据返回值来确定的，之所以这次能编译和执行成功，<br />
是因为两个method（）方法加入了不同的返回值后才能共存在一个Class文件之中。 第6章介<br />
绍Class文件方法表（method_info）的数据结构时曾经提到过，方法重载要求方法具备不同的<br />
特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择，但是在<br />
Class文件格式之中，只要描述符不是完全一致的两个方法就可以共存。 也就是说，两个方法<br />
如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class文件<br />
中的。<br />
由于Java泛型的引入，各种场景（虚拟机解析、 反射等）下的方法调用都可能对原有的<br />
基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。 因此，JCP组织对<br />
虚拟机规范做出了相应的修改，引入了诸如Signature、 LocalVariableTypeTable等新的属性用<br />
于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用<br />
就是存储一个方法在字节码层面的特征签名[3]，这个属性中保存的参数类型并不是原生类<br />
型，而是包括了参数化类型的信息。 修改后的虚拟机规范[4]要求所有能识别49.0以上版本的<br />
Class文件的虚拟机都要能正确地识别Signature参数。<br />
从上面的例子可以看到擦除法对实际编码带来的影响，由于List＜String＞和List＜Integer<br />
＞擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载，这<br />
是一种毫无优雅和美感可言的解决方案，并且存在一定语意上的混乱，譬如上面脚注中提到<br />
的，必须用Sun JDK 1.6的Javac才能编译成功，其他版本或者ECJ编译器都可能拒绝编译。<br />
另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法<br />
的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过<br />
反射手段取得参数化类型的根本依据。<br />
[1]原文地址：http://www.anyang-window.com.cn/quotthis-is-not-a-genericquot-bruce-eckel-eyesof-the-generic-java/。<br />
[2]测试的时候请使用Sun JDK 1.6的Javac编译器进行编译，其他编译器，如Eclipse JDT的ECJ<br />
编译器，仍然可能会拒绝编译这段代码，ECJ编译时会提示&ldquo;Method method（List＜String<br />
＞）has the same erasure method（List＜E＞）as another method in type GenericTypes&rdquo;。<br />
[3]在《 Java虚拟机规范（第2版）》 （JDK 1.5修改后的版本）的&ldquo;&sect;4.4.4 Signatures&rdquo;章节及<br />
《 Java语言规范（第3版）》 的&ldquo;&sect;8.4.2 Method Signature&rdquo;章节中分别定义了字节码层面的方法<br />
特征签名，以及Java代码层面的方法特征签名，特征签名最重要的任务就是作为方法独一无<br />
二且不可重复的ID，在Java代码中的方法特征签名只包括了方法名称、 参数顺序及参数类<br />
型，而在字节码中的特征签名还包括方法返回值及受查异常表，本书中如果指的是字节码层<br />
面的方法签名，笔者会加入限定语进行说明，也请读者根据上下文语境注意区分。<br />
[4]JDK 1.5对虚拟机规范修改：http://jcp.org/aboutJava/communityprocess/maintenance/jsr<br />
924/index.html。<br />
10.3.2 自动装箱、 拆箱与遍历循环<br />
从纯技术的角度来讲，自动装箱、 自动拆箱与遍历循环（Foreach循环）这些语法糖，无<br />
论是实现上还是思想上都不能和上文介绍的泛型相比，两者的难度和深度都有很大差距。 专<br />
门拿出一节来讲解它们只有一个理由：毫无疑问，它们是Java语言里使用得最多的语法糖。<br />
我们通过代码清单10-6和代码清单10-7中所示的代码来看看这些语法糖在编译后会发生什么<br />
样的变化。<br />
代码清单10-6 自动装箱、 拆箱与遍历循环<br />
public static void main（String[]args）{<br />
List＜Integer＞list=Arrays.asList（1，2，3，4）；<br />
//如果在JDK 1.7中，还有另外一颗语法糖[1]<br />
//能让上面这句代码进一步简写成List＜Integer＞list=[1，2，3，4]；<br />
int sum=0；<br />
for（int i：list）{<br />
sum+=i；<br />
}S<br />
ystem.out.println（sum）；<br />
} 代<br />
码清单10-7 自动装箱、 拆箱与遍历循环编译之后<br />
public static void main（String[]args）{<br />
List list=Arrays.asList（new Integer[]{<br />
Integer.valueOf（1），<br />
Integer.valueOf（2），<br />
Integer.valueOf（3），<br />
Integer.valueOf（4）}）；<br />
int sum=0；<br />
for（Iterator localIterator=list.iterator（）；localIterator.hasNext（）；）{<br />
int i=（（Integer）localIterator.next（））.intValue（）；<br />
sum+=i；<br />
}S<br />
ystem.out.println（sum）；<br />
} 代<br />
码清单10-6中一共包含了泛型、 自动装箱、 自动拆箱、 遍历循环与变长参数5种语法<br />
糖，代码清单10-7则展示了它们在编译后的变化。 泛型就不必说了，自动装箱、 拆箱在编译<br />
之后被转化成了对应的包装和还原方法，如本例中的Integer.valueOf（）与<br />
Integer.intValue（）方法，而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循<br />
环需要被遍历的类实现Iterable接口的原因。 最后再看看变长参数，它在调用的时候变成了一<br />
个数组类型的参数，在变长参数出现之前，程序员就是使用数组来完成类似功能的。<br />
这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们注意的地方，代码清单<br />
10-8演示了自动装箱的一些错误用法。<br />
代码清单10-8 自动装箱的陷阱<br />
public static void main（String[]args）{<br />
Integer a=1；<br />
Integer b=2；<br />
Integer c=3；<br />
Integer d=3；<br />
Integer e=321；<br />
Integer f=321；<br />
Long g=3L；<br />
System.out.println（c==d）；<br />
System.out.println（e==f）；<br />
System.out.println（c==（a+b））；<br />
System.out.println（c.equals（a+b））；<br />
System.out.println（g==（a+b））；<br />
System.out.println（g.equals（a+b））；<br />
} 阅<br />
读完代码清单10-8，读者不妨思考两个问题：一是这6句打印语句的输出是什么？二<br />
是这6句打印语句中，解除语法糖后参数会是什么样子？这两个问题的答案可以很容易试验<br />
出来，笔者就暂且略去答案，希望读者自己上机实践一下。 无论读者的回答是否正确，鉴于<br />
包装类的&ldquo;==&rdquo;运算在不遇到算术运算的情况下不会自动拆箱，以及它们equals（）方法不处<br />
理数据转型的关系，笔者建议在实际编码中尽量避免这样使用自动装箱与拆箱。<br />
[1]在本章完稿之后，此语法糖随着Project Coin一起被划分到JDK 1.8中了，在JDK 1.7里不会<br />
包括。<br />
10.3.3 条件编译<br />
许多程序设计语言都提供了条件编译的途径，如C、 C++中使用预处理器指示符<br />
（#ifdef）来完成条件编译。 C、 C++的预处理器最初的任务是解决编译时的代码依赖关系<br />
（如非常常用的#include预处理命令），而在Java语言之中并没有使用预处理器，因为Java语<br />
言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级<br />
节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）无须使用<br />
预处理器。 那Java语言是否有办法实现条件编译呢？<br />
Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。 如代码清单10-<br />
9所示，此代码中的if语句不同于其他Java代码，它在编译阶段就会被&ldquo;运行&rdquo;，生成的字节码<br />
之中只包括&ldquo;System.out.println（&quot;block 1&quot;）；&rdquo;一条语句，并不会包含if语句及另外一个分子<br />
中的&ldquo;System.out.println（&quot;block 2&quot;）；&rdquo;<br />
代码清单10-9 Java语言的条件编译<br />
public static void main（String[]args）{<br />
if（true）{<br />
System.out.println（&quot;block 1&quot;）；<br />
}else{<br />
System.out.println（&quot;block 2&quot;）；<br />
}} 上<br />
述代码编译后Class文件的反编译结果：<br />
public static void main（String[]args）{<br />
System.out.println（&quot;block 1&quot;）；<br />
} 只<br />
能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能<br />
力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译，如代码清单10-10所示的代<br />
码就会被编译器拒绝编译。<br />
代码清单10-10 不能使用其他条件语句来完成条件编译<br />
public static void main（String[]args）{<br />
//编译器将会提示&ldquo;Unreachable code&rdquo;<br />
while（false）{<br />
System.out.println（&quot;&quot;）；<br />
}} J<br />
ava语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编<br />
译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段<br />
（com.sun.tools.javac.comp.Lower类中）完成。 由于这种条件编译的实现方式使用了if语句，<br />
所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句基本块<br />
（Block）级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。<br />
除了本节中介绍的泛型、 自动装箱、 自动拆箱、 遍历循环、 变长参数和条件编译之<br />
外，Java语言还有不少其他的语法糖，如内部类、 枚举类、 断言语句、 对枚举和字符串（在<br />
JDK 1.7中支持）的switch支持、 try语句中定义和关闭资源（在JDK 1.7中支持）等，读者可<br />
以通过跟踪Javac源码、 反编译Class文件等方式了解它们的本质实现，囿于篇幅，笔者就不<br />
再一一介绍了。<br />
10.4 实战：插入式注解处理器<br />
JDK编译优化部分在本书中并没有设置独立的实战章节，因为我们开发程序，考虑的主<br />
要是程序会如何运行，很少会有针对程序编译的需求。 也因为这个原因，在JDK的编译子系<br />
统里面，提供给用户直接控制的功能相对较少，除了第11章会介绍的虚拟机JIT编译的几个<br />
相关参数以外，我们就只有使用JSR-296中定义的插入式注解处理器API来对JDK编译子系统<br />
的行为产生一些影响。<br />
但是笔者并不认为相对于前两部分介绍的内存管理子系统和字节码执行子系统，JDK的<br />
编译子系统就不那么重要。 一套编程语言中编译子系统的优劣，很大程度上决定了程序运行<br />
性能的好坏和编码效率的高低，尤其在Java语言中，运行期即时编译与虚拟机执行子系统非<br />
常紧密地互相依赖、 配合运作（第11章将主要讲解这方面的内容）。 了解JDK如何编译和优<br />
化代码，有助于我们写出适合JDK自优化的程序。 下面我们回到本章的实战中，看看插入式<br />
注解处理器API能实现什么功能。<br />
10.4.1 实战目标<br />
通过阅读Javac编译器的源码，我们知道编译器在把Java程序源码编译为字节码的时候，<br />
会对Java程序源码做各方面的检查校验。 这些校验主要以程序&ldquo;写得对不对&rdquo;为出发点，虽然<br />
也有各种WARNING的信息，但总体来讲还是较少去校验程序&ldquo;写得好不好&rdquo;。 有鉴于此，业<br />
界出现了许多针对程序&ldquo;写得好不好&rdquo;的辅助校验工具，如CheckStyle、 FindBug、 Klocwork<br />
等。 这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完<br />
成，在本节的实战中，我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工<br />
具：NameCheckProcessor。<br />
当然，由于我们的实战都是为了学习和演示技术原理，而不是为了做出一款能媲美<br />
CheckStyle等工具的产品来，所以NameCheckProcessor的目标也仅定为对Java程序命名进行检<br />
查，根据《 Java语言规范（第3版）》 中第6.8节的要求，Java程序命名应当符合下列格式的<br />
书写规范。<br />
类（或接口）：符合驼式命名法，首字母大写。<br />
方法：符合驼式命名法，首字母小写。<br />
字段：<br />
●类或实例变量：符合驼式命名法，首字母小写。<br />
●常量：要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。<br />
上文提到的驼式命名法（Camel Case Name），正如它的名称所表示的那样，是指混合<br />
使用大小写字母来分割构成变量或函数的名字，犹如驼峰一般，这是当前Java语言中主流的<br />
命名规范，我们的实战目标就是为Javac编译器添加一个额外的功能，在编译程序时检查程<br />
序名是否符合上述对类（或接口）、 方法、 字段的命名要求[1]。<br />
[1]在JDK的sample/javac/processing目录中有这次实战的源码（稍微复杂一些，但总体上差距<br />
不大），读者可以阅读参考。<br />
10.4.2 代码实现<br />
要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。 我<br />
们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个<br />
抽象类中只有一个必须覆盖的abstract方法：&ldquo;process（）&rdquo;，它是Javac编译器在执行注解处<br />
理器代码时要调用的过程，我们可以从这个方法的第一个参数&ldquo;annotations&rdquo;中获取到此注解<br />
处理器所要处理的注解集合，从第二个参数&ldquo;roundEnv&rdquo;中访问到当前这个Round中的语法树<br />
节点，每个语法树节点在这里表示为一个Element。 在JDK 1.6新增的javax.lang.model包中定<br />
义了16类Element，包括了Java代码中最常用的元素，如：&ldquo;包（PACKAGE）、 枚举<br />
（ENUM）、 类（CLASS）、 注解（ANNOTATION_TYPE）、 接口（INTERFACE）、 枚举<br />
值（ENUM_CONSTANT）、 字段（FIELD）、 参数（PARAMETER）、 本地变量<br />
（LOCAL_VARIABLE）、 异常（EXCEPTION_PARAMETER）、 方法（METHOD）、 构造<br />
函数（CONSTRUCTOR）、 静态语句块（STATIC_INIT，即static{}块）、 实例语句块<br />
（INSTANCE_INIT，即{}块）、 参数化类型（TYPE_PARAMETER，既泛型尖括号内的类<br />
型）和未定义的其他语法树节点（OTHER）&rdquo;。 除了process（）方法的传入参数之外，还有<br />
一个很常用的实例变量&ldquo;processingEnv&rdquo;，它是AbstractProcessor中的一个protected变量，在注<br />
解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处<br />
理器代码可以直接访问到它。 它代表了注解处理器框架提供的一个上下文环境，要创建新的<br />
代码、 向编译器输出信息、 获取其他工具类等都需要用到这个实例变量。<br />
注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：<br />
@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些<br />
注解感兴趣，可以使用星号&ldquo;*&rdquo;作为通配符代表对所有的注解都感兴趣，后者指出这个注解<br />
处理器可以处理哪些版本的Java代码。<br />
每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内<br />
容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未<br />
发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行<br />
检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。 关于注解处理器<br />
的API，笔者就简单介绍这些，对这个领域有兴趣的读者可以阅读相关的帮助文档。 下面来<br />
看看注解处理器NameCheckProcessor的具体代码，如代码清单10-11所示。<br />
代码清单10-11 注解处理器NameCheckProcessor<br />
//可以用&quot;*&quot;表示支持所有Annotations<br />
@SupportedAnnotationTypes（&quot;*&quot;）<br />
//只支持JDK 1.6的Java代码<br />
@SupportedSourceVersion（SourceVersion.RELEASE_6）<br />
public class NameCheckProcessor extends AbstractProcessor{<br />
private NameChecker nameChecker；<br />
/**<br />
*初始化名称检查插件<br />
*/<br />
@Override<br />
public void init（ProcessingEnvironment processingEnv）{<br />
super.init（processingEnv）；<br />
nameChecker=new NameChecker（processingEnv）；<br />
}/<br />
**<br />
*对输入的语法树的各个节点进行名称检查<br />
*/<br />
@Override<br />
public boolean process（Set＜?extends TypeElement＞annotations,RoundEnvironment roundEnv）{<br />
if（！roundEnv.processingOver（））{<br />
for（Element element：roundEnv.getRootElements（））<br />
nameChecker.checkNames（element）；<br />
}r<br />
eturn false；<br />
}}<br />
从上面代码可以看出，NameCheckProcessor能处理基于JDK 1.6的源码，它不限于特定的<br />
注解，对任何代码都&ldquo;感兴趣&rdquo;，而在process（）方法中是把当前Round中的每一个<br />
RootElement传递到一个名为NameChecker的检查器中执行名称检查逻辑，NameChecker的代码<br />
如代码清单10-12所示。<br />
代码清单10-12 命名检查器NameChecker<br />
/**<br />
*程序名称规范的编译器插件：＜br＞<br />
*如果程序命名不合规范，将会输出一个编译器的WARNING信息<br />
*/<br />
public class NameChecker{<br />
private final Messager messager；<br />
NameCheckScanner nameCheckScanner=new NameCheckScanner（）；<br />
NameChecker（ProcessingEnvironment processsingEnv）{<br />
this.messager=processsingEnv.getMessager（）；<br />
}/<br />
**<br />
*对Java程序命名进行检查，根据《 Java语言规范（第3版）》 第6.8节的要求，Java程序命名应当符合下列格式：<br />
**<br />
＜ul＞<br />
*＜li＞类或接口：符合驼式命名法，首字母大写。<br />
*＜li＞方法：符合驼式命名法，首字母小写。<br />
*＜li＞字段：<br />
*＜ul＞<br />
*＜li＞类、 实例变量：符合驼式命名法，首字母小写。<br />
*＜li＞常量：要求全部大写。<br />
*＜/ul＞<br />
*＜/ul＞<br />
*/<br />
public void checkNames（Element element）{<br />
nameCheckScanner.scan（element）；<br />
}/<br />
**<br />
*名称检查器实现类，继承了JDK 1.6中新提供的ElementScanner6＜br＞<br />
*将会以Visitor模式访问抽象语法树中的元素<br />
*/<br />
private class NameCheckScanner extends ElementScanner6＜Void,Void＞{<br />
/**<br />
*此方法用于检查Java类<br />
*/<br />
@Override<br />
public Void visitType（TypeElement e,Void p）{<br />
scan（e.getTypeParameters（），p）；<br />
checkCamelCase（e,true）；<br />
super.visitType（e,p）；<br />
return null；<br />
}/<br />
**<br />
*检查方法命名是否合法<br />
*/<br />
@Override<br />
public Void visitExecutable（ExecutableElement e,Void p）{<br />
if（e.getKind（）==METHOD）{<br />
Name name=e.getSimpleName（）；<br />
if<br />
（name.contentEquals（e.getEnclosingElement（）.getSimpleName（）））<br />
messager.printMessage（WARNING，&quot;一个普通方法&quot;&quot;+name+&quot;&quot;不应当与类名重复，避免与构造函数产生混淆&quot;，e）；<br />
checkCamelCase（e,false）；<br />
}s<br />
uper.visitExecutable（e,p）；<br />
return null；<br />
}/<br />
**<br />
*检查变量命名是否合法<br />
*/<br />
@Override<br />
public Void visitVariable（VariableElement e,Void p）{<br />
//如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查<br />
if（e.getKind（）==ENUM_CONSTANT||e.getConstantValue（）！=null||heuristicallyConstant（e））<br />
checkAllCaps（e）；<br />
else<br />
checkCamelCase（e,false）；<br />
return null；<br />
}/<br />
**<br />
*判断一个变量是否是常量<br />
*/<br />
private boolean heuristicallyConstant（VariableElement e）{<br />
if（e.getEnclosingElement（）.getKind（）==INTERFACE）<br />
return true；<br />
else if（e.getKind（）==FIELD＆＆e.getModifiers（）.containsAll（EnumSet.of（PUBLIC,STATIC,FINAL）））<br />
return true；<br />
else{<br />
return false；<br />
}}/<br />
**<br />
*检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息<br />
*/<br />
private void checkCamelCase（Element e,boolean initialCaps）{<br />
String name=e.getSimpleName（）.toString（）；<br />
boolean previousUpper=false；<br />
boolean conventional=true；<br />
int firstCodePoint=name.codePointAt（0）；<br />
if（Character.isUpperCase（firstCodePoint））{<br />
previousUpper=true；<br />
if（！initialCaps）{<br />
messager.printMessage（WARNING，&quot;名称&quot;&quot;+name+&quot;&quot;应当以小写字母开头&quot;，e）；<br />
return；<br />
}}<br />
else if（Character.isLowerCase（firstCodePoint））{<br />
if（initialCaps）{<br />
messager.printMessage（WARNING，&quot;名称&quot;&quot;+name+&quot;&quot;应当以大写字母开头&quot;，e）；<br />
return；<br />
}}<br />
else<br />
conventional=false；<br />
if（conventional）{<br />
int cp=firstCodePoint；<br />
for（int i=Character.charCount（cp）；i＜name.length（）；i+=Character.charCount（cp））{<br />
cp=name.codePointAt（i）；<br />
if（Character.isUpperCase（cp））{<br />
if（previousUpper）{<br />
conventional=false；<br />
break；<br />
}p<br />
reviousUpper=true；<br />
}else<br />
previousUpper=false；<br />
}}i<br />
f（！conventional）<br />
messager.printMessage（WARNING，&quot;名称&quot;&quot;+name+&quot;&quot;应当符合驼式命名法（Camel Case Names）&quot;，e）；<br />
}/<br />
**<br />
*大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母<br />
*/<br />
private void checkAllCaps（Element e）{<br />
String name=e.getSimpleName（）.toString（）；<br />
boolean conventional=true；<br />
int firstCodePoint=name.codePointAt（0）；<br />
if（！Character.isUpperCase（firstCodePoint））<br />
conventional=false；<br />
else{<br />
boolean previousUnderscore=false；<br />
int cp=firstCodePoint；<br />
for（int i=Character.charCount（cp）；i＜name.length（）；i+=Character.charCount（cp））{<br />
cp=name.codePointAt（i）；<br />
if（cp==（int）&#39;_&#39;）{<br />
if（previousUnderscore）{<br />
conventional=false；<br />
break；<br />
}p<br />
reviousUnderscore=true；<br />
}else{<br />
previousUnderscore=false；<br />
if（！Character.isUpperCase（cp）＆＆！Character.isDigit（cp））<br />
{c<br />
onventional=false；<br />
break；<br />
}}}}i<br />
f（！conventional）<br />
messager.printMessage（WARNING，&quot;常量&quot;&quot;+name+&quot;&quot;应当全部以大写字母或下划线命名，并且以字母开头&quot;，e）；<br />
}}} N<br />
ameChecker的代码看起来有点长，但实际上注释占了很大一部分，其实即使算上注释<br />
也不到190行。 它通过一个继承于javax.lang.model.util.ElementScanner6的NameCheckScanner<br />
类，以Visitor模式来完成对语法树的遍历，分别执行visitType（）、 visitVariable（）和<br />
visitExecutable（）方法来访问类、 字段和方法，这3个visit方法对各自的命名规则做相应的<br />
检查，checkCamelCase（）与checkAllCaps（）方法则用于实现驼式命名法和全大写命名规<br />
则的检查。<br />
整个注解处理器只需NameCheckProcessor和NameChecker两个类就可以全部完成，为了<br />
验证我们的实战成果，代码清单10-13中提供了一段命名规范的&ldquo;反面教材&rdquo;代码，其中的每<br />
一个类、 方法及字段的命名都存在问题，但是使用普通的Javac编译这段代码时不会提示任<br />
何一个Warning信息。<br />
代码清单10-13 包含了多处不规范命名的代码样例<br />
public class BADLY_NAMED_CODE{<br />
enum colors{<br />
red,blue,green；<br />
}s<br />
tatic final int_FORTY_TWO=42；<br />
public static int NOT_A_CONSTANT=_FORTY_TWO；<br />
protected void BADLY_NAMED_CODE（）{<br />
return；<br />
}p<br />
ublic void NOTcamelCASEmethodNAME（）{<br />
return；<br />
}}<br />
10.4.3 运行与测试<br />
我们可以通过Javac命令的&ldquo;-processor&rdquo;参数来执行编译时需要附带的注解处理器，如果<br />
有多个注解处理器的话，用逗号分隔。 还可以使用-XprintRounds和-XprintProcessorInfo参数<br />
来查看注解处理器运作的详细信息，本次实战中的NameCheckProcessor的编译及执行过程如<br />
代码清单10-14所示。<br />
代码清单10-14 注解处理器的运行过程<br />
D：\src＞javac org/fenixsoft/compile/NameChecker.java<br />
D：\src＞javac org/fenixsoft/compile/NameCheckProcessor.java<br />
D：\src＞javac-processor org.fenixsoft.compile.NameCheckProcessor org/fenixsoft/compile/BADLY_NAMED_CODE.java<br />
org\fenixsoft\compile\BADLY_NAMED_CODE.java：3：警告：名称&quot;BADLY_NAMED_CODE&quot;应当符合驼式命名法（Camel Case Names）<br />
public class BADLY_NAMED_CODE{<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：5：警告：名称&quot;colors&quot;应当以大写字母开头<br />
enum colors{<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头<br />
red,blue,green；<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头<br />
red,blue,green；<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头<br />
red,blue,green；<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头<br />
static final int_FORTY_TWO=42；<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头<br />
public static int NOT_A_CONSTANT=_FORTY_TWO；<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：13：警告：名称&quot;Test&quot;应当以小写字母开头<br />
protected void Test（）{<br />
^o<br />
rg\fenixsoft\compile\BADLY_NAMED_CODE.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头<br />
public void NOTcamelCASEmethodNAME（）{<br />
^<br />
10.4.4 其他应用案例<br />
NameCheckProcessor的实战例子只演示了JSR-269嵌入式注解处理器API中的一部分功<br />
能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator<br />
Annotation Processor[1]（本质上与NameCheckProcessor所做的事情差不多）、 自动为字段生成<br />
getter和setter方法的Project Lombok[2]（根据已有元素生成新的语法树元素）等，读者有兴趣的<br />
话可以参考它们官方站点的相关内容。<br />
[1]官方站点：http://www.hibernate.org/subprojects/validator.html。<br />
[2]官方站点：http://projectlombok.org/。<br />
10.5 本章小结<br />
在本章中，我们从编译器源码实现的层次上了解了Java源代码编译为字节码的过程，分<br />
析了Java语言中泛型、 主动装箱/拆箱、 条件编译等多种语法糖的前因后果，并实战练习了如<br />
何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。 如本章概述中所说的<br />
那样，在前端编译器中，&ldquo;优化&rdquo;手段主要用于提升程序的编码效率，之所以把Javac这类将<br />
Java代码转变为字节码的编译器称做&ldquo;前端编译器&rdquo;，是因为它只完成了从程序到抽象语法树<br />
或中间字节码的生成，而在此之后，还有一组内置于虚拟机内部的&ldquo;后端编译器&rdquo;完成了从字<br />
节码生成本地机器码的过程，即前面多次提到的即时编译器或JIT编译器，这个编译器的编<br />
译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。 在第11章中，我们将会介<br />
绍即时编译器的运作和优化过程。<br />
第11章 晚期（运行期）优化<br />
从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如<br />
一场没有终点、 永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛<br />
车。<br />
11.1 概述<br />
在部分的商用虚拟机（Sun HotSpot、 IBM J9）中，Java程序最初是通过解释器<br />
（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把<br />
这些代码认定为&ldquo;热点代码&rdquo;（Hot Spot Code）。 为了提高热点代码的执行效率，在运行时，<br />
虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个<br />
任务的编译器称为即时编译器（Just In Time Compiler，下文中简称JIT编译器）。<br />
即时编译器并不是虚拟机必需的部分，Java虚拟机规范并没有规定Java虚拟机内必须要<br />
有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。 但是，即时编译器编译<br />
性能的好坏、 代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，<br />
它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。 在本章中，我们将走进虚拟机的<br />
内部，探索即时编译器的运作过程。<br />
由于Java虚拟机规范没有具体的约束规则去限制即时编译器应该如何实现，所以这部分<br />
功能完全是与虚拟机具体实现（Implementation Specific）相关的内容，如无特殊说明，本章<br />
提及的编译器、 即时编译器都是指HotSpot虚拟机内的即时编译器，虚拟机也是特指HotSpot<br />
虚拟机。 不过，本章的大部分内容是描述即时编译器的行为，涉及编译器实现层面的内容较<br />
少，而主流虚拟机中即时编译器的行为又有很多相似和相通之处，因此，对其他虚拟机来说<br />
也具有较高的参考意义。<br />
11.2 HotSpot虚拟机内的即时编译器<br />
在本节中，我们将要了解HotSpot虚拟机内的即时编译器的运作过程，同时，还要解决<br />
以下几个问题：<br />
为何HotSpot虚拟机要使用解释器与编译器并存的架构？<br />
为何HotSpot虚拟机要实现两个不同的即时编译器？<br />
程序何时使用解释器执行？何时使用编译器执行？<br />
哪些程序代码会被编译为本地代码？如何编译为本地代码？<br />
如何从外部观察即时编译器的编译过程和编译结果？<br />
11.2.1 解释器与编译器<br />
尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚<br />
拟机，如HotSpot、 J9等，都同时包含解释器与编译器[1]。 解释器与编译器两者各有优势：当<br />
程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。<br />
在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码<br />
之后，可以获取更高的执行效率。 当程序运行环境中内存资源限制较大（如部分嵌入式系统<br />
中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。 同时，解释器还可<br />
以作为编译器激进优化时的一个&ldquo;逃生门&rdquo;，让编译器根据概率选择一些大多数时候都能提升<br />
运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、<br />
出现&ldquo;罕见陷阱&rdquo;（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继<br />
续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器[2]担任&ldquo;逃生门&rdquo;的<br />
角色），因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，如图11-1所示。<br />
图 11-1 解释器与编译器的交互<br />
HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，<br />
或者简称为C1编译器和C2编译器（也叫Opto编译器）。 目前主流的HotSpot虚拟机（Sun系列<br />
JDK 1.7及之前版本的虚拟机）中，默认采用解释器与其中一个编译器直接配合的方式工<br />
作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿<br />
主机器的硬件性能自动选择运行模式，用户也可以使用&ldquo;-client&rdquo;或&ldquo;-server&rdquo;参数去强制指定虚<br />
拟机运行在Client模式或Server模式。<br />
无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方<br />
式在虚拟机中称为&ldquo;混合模式&rdquo;（Mixed Mode），用户可以使用参数&ldquo;-Xint&rdquo;强制虚拟机运行<br />
于&ldquo;解释模式&rdquo;（Interpreted Mode），这时编译器完全不介入工作，全部代码都使用解释方式<br />
执行。 另外，也可以使用参数&ldquo;-Xcomp&rdquo;强制虚拟机运行于&ldquo;编译模式&rdquo;（Compiled Mode）[3]，<br />
这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过<br />
程，可以通过虚拟机的&ldquo;-version&rdquo;命令的输出结果显示出这3种模式，如代码清单11-1所示，<br />
请注意黑体字部分。<br />
代码清单11-1 虚拟机执行模式<br />
C：\＞java-version<br />
java version&quot;1.6.0_22&quot;<br />
Java（TM）SE Runtime Environment（build 1.6.0_22-b04）<br />
Dynamic Code Evolution 64-Bit Server VM（build 0.2-b02-internal，19.0-b04-internal,mixed mode）<br />
C：\＞java-Xint-version<br />
java version&quot;1.6.0_22&quot;<br />
Java（TM）SE Runtime Environment（build 1.6.0_22-b04）<br />
Dynamic Code Evolution 64-Bit Server VM（build 0.2-b02-internal，19.0-b04-internal,interpreted mode）<br />
C：\＞java-Xcomp-version<br />
java version&quot;1.6.0_22&quot;<br />
Java（TM）SE Runtime Environment（build 1.6.0_22-b04）<br />
Dynamic Code Evolution 64-Bit Server VM（build 0.2-b02-internal，19.0-b04-internal,compiled mode）<br />
由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，<br />
所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收<br />
集性能监控信息，这对解释执行的速度也有影响。 为了在程序启动响应速度与运行效率之间<br />
达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）[4]的策略，分层<br />
编译的概念在JDK 1.6时期出现，后来一直处于改进阶段，最终在JDK 1.7的Server模式虚拟<br />
机中作为默认编译策略被开启。 分层编译根据编译器编译、 优化的规模与耗时，划分出不同<br />
的编译层次，其中包括：<br />
第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。<br />
第1层，也称为C1编译，将字节码编译为本地代码，进行简单、 可靠的优化，如有必要<br />
将加入性能监控的逻辑。<br />
第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些<br />
编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。<br />
实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被<br />
多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质<br />
量，在解释执行的时候也无须再承担收集性能监控信息的任务。<br />
[1]作为三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会存在本书中所说<br />
的&ldquo;启动响应时间长&rdquo;之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关<br />
注启动时间。<br />
[2]在虚拟机中习惯将Client Compiler称为C1，将Server Compiler称为C2。<br />
[3]在最新的Sun HotSpot中，已经去掉了-Xcomp参数。<br />
[4]Tiered Compilation的概念在JDK 1.6时期出现，但JDK 1.7之前需要使用-XX：<br />
+TieredCompilation参数来手动开启，如果不开启分层编译策略，而虚拟机又运行在Server模<br />
式，Server Compiler需要性能监控信息提供编译依据，则可以由解释器收集性能监控信息供<br />
Server Compiler使用。 分层编译的相关资料可参见：<br />
http://weblogs.java.net/blog/forax/archive/2010/09/04/tiered-compilation。<br />
11.2.2 编译对象与触发条件<br />
上文中提到过，在运行过程中会被即时编译器编译的&ldquo;热点代码&rdquo;有两类，即：<br />
被多次调用的方法。<br />
被多次执行的循环体。<br />
前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成<br />
为&ldquo;热点代码&rdquo;是理所当然的。 而后者则是为了解决一个方法只被调用过一次或少量的几次，<br />
但是方法体内部存在循环次数较多的循环体的问题，这样循环体的代码也被重复执行多次，<br />
因此这些代码也应该认为是&ldquo;热点代码&rdquo;。<br />
对于第一种情况，由于是由方法调用触发的编译，因此编译器理所当然地会以整个方法<br />
作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。 而对于后一种情况，尽管编译<br />
动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对<br />
象。 这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（On<br />
Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。<br />
读者可能还会有疑问，在上面的文字描述中，无论是&ldquo;多次执行的方法&rdquo;，还是&ldquo;多次执<br />
行的代码块&rdquo;，所谓&ldquo;多次&rdquo;都不是一个具体、 严谨的用语，那到底多少次才算&ldquo;多次&rdquo;呢？还<br />
有一个问题，就是虚拟机如何统计一个方法或一段代码被执行过多少次呢？解决了这两个问<br />
题，也就回答了即时编译被触发的条件。<br />
判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测<br />
（Hot Spot Detection），其实进行热点探测并不一定要知道方法具体被调用了多少次，目前<br />
主要的热点探测判定方式有两种[1]，分别如下。<br />
基于采样的热点探测（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周<br />
期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就<br />
是&ldquo;热点方法&rdquo;。 基于采样的热点探测的好处是实现简单、 高效，还可以很容易地获取方法调<br />
用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线<br />
程阻塞或别的外界因素的影响而扰乱热点探测。<br />
基于计数器的热点探测（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会<br />
为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的<br />
阈值就认为它是&ldquo;热点方法&rdquo;。 这种统计方法实现起来麻烦一些，需要为每个方法建立并维护<br />
计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对来说更加精确和严<br />
谨。<br />
在HotSpot虚拟机中使用的是第二种&mdash;&mdash;基于计数器的热点探测方法，因此它为每个方<br />
法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge<br />
Counter）。<br />
在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈<br />
值溢出了，就会触发JIT编译。<br />
我们首先来看看方法调用计数器。 顾名思义，这个计数器就用于统计方法被调用的次<br />
数，它的默认阈值在Client模式下是1500次，在Server模式下是10 000次，这个阈值可以通过<br />
虚拟机参数-XX：CompileThreshold来人为设定。 当一个方法被调用时，会先检查该方法是否<br />
存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。 如果不存在已<br />
被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器<br />
值之和是否超过方法调用计数器的阈值。 如果已超过阈值，那么将会向即时编译器提交一个<br />
该方法的代码编译请求。<br />
如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照<br />
解释方式执行字节码，直到提交的请求被编译器编译完成。 当编译工作完成之后，这个方法<br />
的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。<br />
整个JIT编译的交互过程如图11-2所示。<br />
图 11-2 方法调用计数器触发即时编译<br />
如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相<br />
对的执行频率，即一段时间之内方法被调用的次数。 当超过一定的时间限度，如果方法的调<br />
用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，<br />
这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计<br />
的半衰周期（Counter Half Life Time）。 进行热度衰减的动作是在虚拟机进行垃圾收集时顺<br />
便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计<br />
方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代<br />
码。 另外，可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。<br />
现在我们再来看看另外一个计数器&mdash;&mdash;回边计数器，它的作用是统计一个方法中循环体<br />
代码执行的次数[2]，在字节码中遇到控制流向后跳转的指令称为&ldquo;回边&rdquo;（Back Edge）。 显<br />
然，建立回边计数器统计的目的就是为了触发OSR编译。<br />
关于回边计数器的阈值，虽然HotSpot虚拟机也提供了一个类似于方法调用计数器阈值-<br />
XX：CompileThreshold的参数-XX：BackEdgeThreshold供用户设置，但是当前的虚拟机实际<br />
上并未使用此参数，因此我们需要设置另外一个参数-XX：OnStackReplacePercentage来间接<br />
调整回边计数器的阈值，其计算公式如下。<br />
虚拟机运行在Client模式下，回边计数器阈值计算公式为：<br />
方法调用计数器阈值（CompileThreshold）&times;OSR比率（OnStackReplacePercentage）/100<br />
其中OnStackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机的回<br />
边计数器的阈值为13995。<br />
虚拟机运行在Server模式下，回边计数器阈值的计算公式为：<br />
方法调用计数器阈值（CompileThreshold）&times;（OSR比率（OnStackReplacePercentage）-解<br />
释器监控比率（InterpreterProfilePercentage）/100<br />
其中OnStackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，如<br />
果都取默认值，那Server模式虚拟机回边计数器的阈值为10700。<br />
当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版<br />
本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法<br />
调用计数器与回边计数器值之和是否超过回边计数器的阈值。 当超过阈值的时候，将会提交<br />
一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待<br />
编译器输出编译结果，整个执行过程如图11-3所示。<br />
图 11-3 回边计数器触发即时编译<br />
与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是<br />
该方法循环执行的绝对次数。 当计数器溢出的时候，它还会把方法计数器的值也调整到溢出<br />
状态，这样下次再进入该方法的时候就会执行标准编译过程。<br />
最后需要提醒一点，图11-2和图11-3都仅仅描述了Client VM的即时编译方式，对于<br />
Server VM来说，执行情况会比上面的描述更复杂一些。 从理论上了解过编译对象和编译触<br />
发条件后，我们再从HotSpot虚拟机的源码中观察一下，在MethodOop.hpp（一个methodOop对<br />
象代表了一个Java方法）中，定义了Java方法在虚拟机中的内存布局，如下所示：<br />
在这个内存布局中，一行长度为32 bit，从中可以清楚地看到方法调用计数器和回边计<br />
数器所在的位置和长度。 还有from_compiled_entry和from_interpreted_entry这两个方法的入<br />
口。<br />
[1]除这两种方式外，还有其他热点代码的探测方式，如基于&ldquo;踪迹&rdquo;（Trace）的热点探测在<br />
最近相当流行，像FireFox中的TraceMonkey和Dalvik中新的JIT编译器都用了这种热点探测方<br />
式。<br />
[2]准确地说，应当是回边的次数而不是循环次数，因为并非所有的循环都是回边，如空循环<br />
实际上就可以视为自己跳转到自己的过程，因此并不算作控制流向后跳转，也不会被回边计<br />
数器统计。<br />
11.2.3 编译过程<br />
在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代<br />
码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程<br />
中进行。 用户可以通过参数-XX：-BackgroundCompilation来禁止后台编译，在禁止后台编译<br />
后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译<br />
过程完成后再开始执行编译器输出的本地代码。<br />
那么在后台执行编译的过程中，编译器做了什么事情呢？Server Compiler和Client<br />
Compiler两个编译器的编译过程是不一样的。 对于Client Compiler来说，它是一个简单快速的<br />
三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。<br />
在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（HighLevel Intermediate Representaion,HIR）。 HIR使用静态单分配（Static Single Assignment,SSA）<br />
的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易<br />
实现。 在此之前编译器会在字节码上完成一部分基础优化，如方法内联、 常量传播等优化将<br />
会在字节码被构造成HIR之前完成。<br />
在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level<br />
Intermediate Representation,LIR），而在此之前会在HIR上完成另外一些优化，如空值检查消<br />
除、 范围检查消除等，以便让HIR达到更高效的代码表示形式。<br />
最后阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR<br />
上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。 Client Compiler的<br />
大致执行过程如图11-4所示。<br />
图 11-4 Client Compiler架构<br />
而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的<br />
编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的<br />
优化强度，它会执行所有经典的优化动作，如无用代码消除（Dead Code Elimination）、 循<br />
环展开（Loop Unrolling）、 循环表达式外提（Loop Expression Hoisting）、 消除公共子表达<br />
式（Common Subexpression Elimination）、 常量传播（Constant Propagation）、 基本块重排序<br />
（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如范围<br />
检查消除（Range Check Elimination）、 空值检查消除（Null Check Elimination，不过并非所<br />
有的空值检查消除都是依赖编译器优化的，有一些是在代码运行过程中自动优化了）等。 另<br />
外，还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优<br />
化，如守护内联（Guarded Inlining）、 分支频率预测（Branch Frequency Prediction）等。 本章<br />
的下半部分将会挑选上述的一部分优化手段进行分析和讲解。<br />
Server Compiler的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器<br />
架构（如RISC）上的大寄存器集合。 以即时编译的标准来看，Server Compiler无疑是比较缓<br />
慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler<br />
编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间<br />
开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。<br />
在本节中，涉及了许多编译原理和代码优化中的概念名词，没有这方面基础的读者，阅<br />
读起来会感觉到抽象和理论化。 有这种感觉并不奇怪，JIT编译过程本来就是一个虚拟机中<br />
最体现技术水平也是最复杂的部分，不可能以较短的篇幅就介绍得很详细，另外，这个过程<br />
对Java开发来说是透明的，程序员平时无法感知它的存在，还好HotSpot虚拟机提供了两个可<br />
视化的工具，让我们可以&ldquo;看见&rdquo;JIT编译器的优化过程，在稍后笔者将演示这个过程。<br />
11.2.4 查看及分析即时编译结果<br />
一般来说，虚拟机的即时编译过程对用户程序是完全透明的，虚拟机通过解释执行代码<br />
还是编译执行代码，对于用户来说并没有什么影响（执行结果没有影响，速度上会有很大差<br />
别），在大多数情况下用户也没有必要知道。 但是虚拟机也提供了一些参数用来输出即时编<br />
译和某些优化手段（如方法内联）的执行状况，本节将介绍如何从外部观察虚拟机的即时编<br />
译行为。<br />
本节中提到的运行参数有一部分需要Debug或FastDebug版虚拟机的支持，Product版的虚<br />
拟机无法使用这部分参数。 如果读者使用的是根据本书第1章的内容自己编译的JDK，注意<br />
将SKIP_DEBUG_BUILD或SKIP_FASTDEBUG_BUILD参数设置为false，也可以在OpenJDK网<br />
站上直接下载FastDebug版的JDK（从JDK 6u25之后Oracle官网就不再提供FastDebug的JDK下<br />
载了）。 注意，本节中所有的测试都基于代码清单11-2所示的Java代码。<br />
代码清单11-2 测试代码<br />
public static final int NUM=15000；<br />
public static int doubleValue（int i）{<br />
//这个空循环用于后面演示JIT代码优化过程<br />
for（int j=0；j＜100000；j++）；<br />
return i*2；<br />
}p<br />
ublic static long calcSum（）{<br />
long sum=0；<br />
for（int i=1；i＜=100；i++）{<br />
sum+=doubleValue（i）；<br />
}r<br />
eturn sum；<br />
}p<br />
ublic static void main（String[]args）{<br />
for（int i=0；i＜NUM；i++）{<br />
calcSum（）；<br />
}} 首<br />
先运行这段代码，并且确认这段代码是否触发了即时编译，要知道某个方法是否被编<br />
译过，可以使用参数-XX：+PrintCompilation要求虚拟机在即时编译时将被编译成本地代码的<br />
方法名称打印出来，如代码清单11-3所示（其中带有&ldquo;%&rdquo;的输出说明是由回边计数器触发的<br />
OSR编译）。<br />
代码清单11-3 被即时编译的代码<br />
VM option&#39;+PrintCompilation&#39;<br />
310 1 java.lang.String：charAt（33 bytes）<br />
329 2 org.fenixsoft.jit.Test：calcSum（26 bytes）<br />
329 3 org.fenixsoft.jit.Test：doubleValue（4 bytes）<br />
332 1%org.fenixsoft.jit.Test：main@5（20 bytes）<br />
从代码清单11-3输出的确认信息中可以确认main（）、 calcSum（）和doubleValue（）方<br />
法已经被编译，我们还可以加上参数-XX：+PrintInlining要求虚拟机输出方法内联信息，如代<br />
码清单11-4所示。<br />
代码清单11-4 内联信息<br />
VM option&#39;+PrintCompilation&#39;<br />
VM option&#39;+PrintInlining&#39;<br />
273 1 java.lang.String：charAt（33 bytes）<br />
291 2 org.fenixsoft.jit.Test：calcSum（26 bytes）<br />
@9 org.fenixsoft.jit.Test：doubleValue inline（hot）<br />
294 3 org.fenixsoft.jit.Test：doubleValue（4 bytes）<br />
295 1%org.fenixsoft.jit.Test：main@5（20 bytes）<br />
@5 org.fenixsoft.jit.Test：calcSum inline（hot）<br />
@9 org.fenixsoft.jit.Test：doubleValue inline（hot）<br />
从代码清单11-4的输出中可以看到方法doubleValue（）被内联编译到calcSum（）中，而<br />
calcSum（）又被内联编译到方法main（）中，所以虚拟机再次执行main（）方法的时候（举<br />
例而已，main（）方法并不会运行两次），calcSum（）和doubleValue（）方法都不会再被<br />
调用，它们的代码逻辑都被直接内联到main（）方法中了。<br />
除了查看哪些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，不过<br />
如果虚拟机输出一串0和1，对于我们的阅读来说是没有意义的，机器码必须反汇编成基本的<br />
汇编语言才可能被阅读。 虚拟机提供了一组通用的反汇编接口[1]，可以接入各种平台下的反<br />
汇编适配器来使用，如使用32位80x86平台则选用hsdis-i386适配器，其余平台的适配器还有<br />
hsdis-amd64、 hsdis-sparc和hsdis-sparcv9等，可以下载或自己编译出反汇编适配器[2]，然后将<br />
其放置在JRE/bin/client或/server目录下，只要与jvm.dll的路径相同即可被虚拟机调用。 在为<br />
虚拟机安装了反汇编适配器之后，就可以使用-XX：+PrintAssembly参数要求虚拟机打印编译<br />
方法的汇编代码了，具体的操作可以参考本书4.2.7节。<br />
如果没有HSDIS插件支持，也可以使用-XX：+PrintOptoAssembly（用于Server VM）或-<br />
XX：+PrintLIR（用于Client VM）来输出比较接近最终结果的中间代码表示，代码清单11-2<br />
被编译后部分反汇编（使用-XX：+PrintOptoAssembly）的输出结果如代码清单11-5所示。 从<br />
阅读角度来说，使用-XX：+PrintOptoAssembly参数输出的伪汇编结果包含了更多的信息（主<br />
要是注释），利于阅读并理解虚拟机JIT编译器的优化结果。<br />
代码清单11-5 本地机器码反汇编信息（部分）<br />
&hellip;&hellip;<br />
000 B1：#N1＜-BLOCK HEAD IS JUNK Freq：1<br />
000 pushq rbp<br />
subq rsp，#16#Create frame<br />
nop#nop for patch_verified_entry<br />
006 movl RAX,RDX#spill<br />
008 sall RAX，#1<br />
00a addq rsp，16#Destroy frame<br />
popq rbp<br />
testl rax，[rip+#offset_to_poll_page]#Safepoint：poll for GC<br />
&hellip;&hellip;<br />
前面提到的使用-XX：+PrintAssembly参数输出反汇编信息需要Debug或者FastDebug版的<br />
虚拟机才能直接支持，如果使用Product版的虚拟机，则需要加入参数-XX：<br />
+UnlockDiagnosticVMOptions打开虚拟机诊断模式后才能使用。<br />
如果除了本地代码的生成结果外，还想再进一步跟踪本地代码生成的具体过程，那还可<br />
以使用参数-XX：+PrintCFGToFile（使用Client Compiler）或-XX：PrintIdealGraphFile（使用<br />
Server Compiler）令虚拟机将编译过程中各个阶段的数据（例如，对C1编译器来说，包括字<br />
节码、 HIR生成、 LIR生成、 寄存器分配过程、 本地代码生成等数据）输出到文件中。 然后使<br />
用Java HotSpot Client Compiler Visualizer [3]（用于分析Client Compiler）或Ideal Graph<br />
Visualizer[4]（用于分析Server Compiler）打开这些数据文件进行分析。 以Server Compiler为<br />
例，笔者分析一下JIT编译器的代码生成过程。<br />
Server Compiler的中间代码表示是一种名为Ideal的SSA形式程序依赖图（Program<br />
Dependence Graph），在运行Java程序的JVM参数中加入&ldquo;-XX：PrintIdealGraphLevel=2-XX：<br />
PrintIdealGraphFile=ideal.xml&rdquo;，编译后将产生一个名为ideal.xml的文件，它包含了Server<br />
Compiler编译代码的过程信息，可以使用Ideal Graph Visualizer对这些信息进行分析。<br />
Ideal Graph Visualizer加载ideal.xml文件后，在Outline面板上将显示程序运行过程中编译<br />
过的方法列表，如图11-5所示。 这里列出的方法是代码清单11-2中的测试代码，其中<br />
doubleValue（）方法出现了两次，这是由于该方法的编译结果存在标准编译和OSR编译两个<br />
版本。 在代码清单11-2中，笔者特别为doubleValue（）方法增加了一个空循环，这个循环对<br />
方法的运算结果不会产生影响，但如果没有任何优化，执行空循环会占用CPU时间，到今天<br />
还有许多程序设计的入门教程把空循环当做程序延时的手段来介绍，在Java中这样的做法真<br />
的能起到延时的作用吗？<br />
图 11-5 编译过的方法列表<br />
展开方法根节点，可以看到下面罗列了方法优化过程的各个阶段（根据优化措施的不<br />
同，每个方法所经过的阶段也会有所差别）的Ideal图，我们先打开&ldquo;After Parsing&rdquo;这个阶段。<br />
上文提到，JIT编译器在编译一个Java方法时，首先要把字节码解析成某种中间表示形式，然<br />
后才可以继续做分析和优化，最终生成代码。 &ldquo;After Parsing&rdquo;就是Server Compiler刚完成解<br />
析，还没有做任何优化时的Ideal图表示。 在打开这个图后，读者会看到其中有很多有颜色的<br />
方块，如图11-6所示。 每一个方块就代表了一个程序的基本块（Basic Block），基本块的特<br />
点是只有唯一的一个入口和唯一的一个出口，只要基本块中第一条指令执行了，那么基本块<br />
内所有执行都会按照顺序仅执行一次。<br />
代码清单11-2的doubleValue（）方法虽然只有简单的两行字，但是按基本块划分后，形<br />
成的图形结构要比想象中复杂得多，这一方面是要满足Java语言所定义的安全需要（如类型<br />
安全、 空指针检查）和Java虚拟机的运作需要（如Safepoint轮询），另一方面是由于有些程<br />
序代码中一行语句就可能形成好几个基本块（例如循环）。 对于例子中的doubleValue（）方<br />
法，如果忽略语言安全检查的基本块，可以简单理解为按顺序执行了以下几件事情：<br />
1）程序入口，建立栈帧。<br />
2）设置j=0，进行Safepoint轮询，跳转到4）的条件检查。<br />
3）执行j++。<br />
4）条件检查，如果j＜100000，跳转到3）。<br />
5）设置i=i*2，进行Safepoint轮询，函数返回。<br />
图 11-6 基本块图示（1）<br />
以上几个步骤，反映到Ideal Graph Visualizer的图上，就是如图11-7所示的内容。 这样我<br />
们要看空循环是否优化，或者何时优化，只要观察代表循环的基本块是否消除，或者何时消<br />
除就可以了。<br />
要观察到这一点，可以在Outline面板上右键点击&ldquo;Difference to current graph&rdquo;，让软件自<br />
动分析指定阶段与当前打开的Ideal图之间的差异，如果基本块被消除了，将会以红色显示。<br />
对&ldquo;After Parsing&rdquo;和&ldquo;PhaseIdealLoop 1&rdquo;阶段的Ideal图进行差异分析，发现在&ldquo;PhaseIdealLoop<br />
1&rdquo;阶段循环操作被消除了，如图11-8所示，这也就说明空循环实际上是不会被执行的。<br />
图 11-7 基本块图示（2）<br />
图 11-8 基本块图示（3）<br />
从&ldquo;After Parsing&rdquo;阶段开始，一直到最后的&ldquo;Final Code&rdquo;阶段，可以看到doubleValue（）<br />
方法的Ideal图从繁到简的变迁过程，这也是Java虚拟机在尽力优化代码的过程。 到了最后<br />
的&ldquo;Final Code&rdquo;阶段，不仅空循环的开销消除了，许多语言安全和Safepoint轮询的操作也一起<br />
消除了，因为编译器判断即使不做这些安全保障，虚拟机也不会受到威胁。<br />
最后提醒一下读者，要输出CFG或IdealGraph文件，需要一个Debug版或FastDebug版的虚<br />
拟机支持，Product版的虚拟机无法输出这些文件。<br />
[1]相关信息：http://wikis.sun.com/display/HotSpotInternals/PrintAssembly。<br />
[2]HSDIS的源码可以从以下地址获取：<br />
http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/。 另外，相关网站可以<br />
下载一个已经编译好了的适合32位80x86平台使用的反汇编适配器，如在ITeye的高级语言虚<br />
拟机圈子的共享区（http://hllvm.group.iteye.com/group/share）中可以下载。<br />
[3]官方站点：http://java.net/projects/c1visualizer/。<br />
[4]官方站点：http://ssw.jku.at/General/Staff/TW/igv.html。<br />
11.3 编译优化技术<br />
Java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的共<br />
识，除去虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是虚拟<br />
机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中（在JDK 1.3之<br />
后，Javac就去除了-O选项，不会生成任何字节码级别的优化代码了），因此一般来说，即<br />
时编译器产生的本地代码会比Javac产生的字节码更加优秀[1]。 下面，笔者将介绍一些HotSpot<br />
虚拟机的即时编译器在生成代码时采用的代码优化技术。<br />
11.3.1 优化技术概览<br />
在Sun官方的Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、 在即时编译<br />
器中采用的优化技术列表[2]（见表11-1），其中有不少经典编译器的优化手段，也有许多针<br />
对Java语言（准确地说是针对运行在Java虚拟机上的所有语言）本身进行的优化技术，本节<br />
将对这些技术进行概括性的介绍，在后面几节中，再挑选若干重要且典型的优化，与读者一<br />
起看看优化前后的代码产生了怎样的变化。</p>

<p><br />
上述的优化技术看起来很多，而且从名字看都显得有点&ldquo;高深莫测&rdquo;，虽然实现这些优化<br />
也许确实有些难度，但大部分技术理解起来都并不困难。 为了消除读者对这些优化技术的陌<br />
生感，笔者举一个简单的例子，即通过大家熟悉的Java代码变化来展示其中几种优化技术是<br />
如何发挥作用的（仅使用Java代码来表示而已）。 首先从原始代码开始，如代码清单11-6所<br />
示[3]。<br />
代码清单11-6 优化前的原始代码<br />
static class B{<br />
int value；<br />
final int get（）{<br />
return value；<br />
}}p<br />
ublic void foo（）{<br />
y=b.get（）；<br />
//&hellip;&hellip;do stuff&hellip;&hellip;<br />
z=b.get（）；<br />
sum=y+z；<br />
} 首<br />
先需要明确的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝<br />
不是建立在Java源码之上的，为了展示方便，笔者使用了Java语言的语法来表示这些优化技<br />
术所发挥的作用。<br />
代码清单11-6的代码已经非常简单了，但是仍有许多优化的余地。 第一步进行方法内联<br />
（Method Inlining），方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是<br />
去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀之<br />
后可以便于在更大范围上采取后续的优化手段，从而获取更好的优化效果。 因此，各种编译<br />
器一般都会把内联优化放在优化序列的最靠前位置。 内联后的代码如代码清单11-7所示。<br />
代码清单11-7 内联后的代码<br />
public void foo（）{<br />
y=b.value；<br />
//&hellip;&hellip;do stuff&hellip;&hellip;<br />
z=b.value；<br />
sum=y+z；<br />
} 第<br />
二步进行冗余访问消除（Redundant Loads Elimination），假设代码中间注释掉<br />
的&ldquo;dostuff&hellip;&hellip;&rdquo;所代表的操作不会改变b.value的值，那就可以把&ldquo;z=b.value&rdquo;替换为&ldquo;z=y&rdquo;，因<br />
为上一句&ldquo;y=b.value&rdquo;已经保证了变量y与b.value是一致的，这样就可以不再去访问对象b的局<br />
部变量了。 如果把b.value看做是一个表达式，那也可以把这项优化看成是公共子表达式消除<br />
（Common Subexpression Elimination），优化后的代码如代码清单11-8所示。<br />
代码清单11-8 冗余存储消除的代码<br />
public void foo（）{<br />
y=b.value；<br />
//&hellip;&hellip;do stuff&hellip;&hellip;<br />
z=y；<br />
sum=y+z；<br />
} 第<br />
三步我们进行复写传播（Copy Propagation），因为在这段程序的逻辑中并没有必要使<br />
用一个额外的变量&ldquo;z&rdquo;，它与变量&ldquo;y&rdquo;是完全相等的，因此可以使用&ldquo;y&rdquo;来代替&ldquo;z&rdquo;。 复写传播<br />
之后程序如代码清单11-9所示。<br />
代码清单11-9 复写传播的代码<br />
public void foo（）{<br />
y=b.value；<br />
//&hellip;&hellip;do stuff&hellip;&hellip;<br />
y=y；<br />
sum=y+y；<br />
} 第<br />
四步我们进行无用代码消除（Dead Code Elimination）。 无用代码可能是永远不会被<br />
执行的代码，也可能是完全没有意义的代码，因此，它又形象地称为&ldquo;Dead Code&rdquo;，在代码<br />
清单11-9中，&ldquo;y=y&rdquo;是没有意义的，把它消除后的程序如代码清单11-10所示。<br />
代码清单11-10 进行无用代码消除的代码<br />
public void foo（）{<br />
y=b.value；<br />
//&hellip;&hellip;do stuff&hellip;&hellip;<br />
sum=y+y；<br />
} 经<br />
过四次优化之后，代码清单11-10与代码清单11-6所达到的效果是一致的，但是前者比<br />
后者省略了许多语句（体现在字节码和机器码指令上的差距会更大），执行效率也会更高。<br />
编译器的这些优化技术实现起来也许比较复杂，但是要理解它们的行为对于一个普通的程序<br />
员来说是没有困难的，接下来，我们将继续查看如下的几项最有代表性的优化技术是如何运<br />
作的，它们分别是：<br />
语言无关的经典优化技术之一：公共子表达式消除。<br />
语言相关的经典优化技术之一：数组范围检查消除。<br />
最重要的优化技术之一：方法内联。<br />
最前沿的优化技术之一：逃逸分析。<br />
[1]本地代码与字节码两者是无法直接比较的，准确地说应当是指：由编译器优化得到的本地<br />
代码与由解释器解释字节码后实际执行的本地代码之间的对比。<br />
[2]地址：http://wikis.sun.com/display/HotSpotInternals/PerformanceTacticIndex。<br />
[3]本例修改自：<br />
http://download.oracle.com/docs/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/underst_jit.html。<br />
11.3.2 公共子表达式消除<br />
公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，它的含义是：如果一<br />
个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么<br />
E的这次出现就成为了公共子表达式。 对于这种表达式，没有必要花时间再对它进行计算，<br />
只需要直接用前面计算过的表达式结果代替E就可以了。 如果这种优化仅限于程序的基本块<br />
内，便称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优<br />
化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common<br />
Subexpression Elimination）。 举个简单的例子来说明它的优化过程，假设存在如下代码：<br />
int d=（c * b）*12+a+（a+b * c）；<br />
如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码将如代码清单11-11<br />
所示，是完全遵照Java源码的写法直译而成的。<br />
代码清单11-11 未做任何优化的字节码<br />
iload_2//b<br />
imul//计算b * c<br />
bipush 12//推入12<br />
imul//计算（c * b）*12<br />
iload_1//a<br />
iadd//计算（c * b）*12+a<br />
iload_1//a<br />
iload_2//b<br />
iload_3//c<br />
imul//计算b * c<br />
iadd//计算a+b * c<br />
iadd//计算（c * b）*12+a+（a+b * c）<br />
istore 4<br />
当这段代码进入到虚拟机即时编译器后，它将进行如下优化：编译器检测到&ldquo;c * b&rdquo;与&ldquo;b<br />
* c&rdquo;是一样的表达式，而且在计算期间b与c的值是不变的。 因此，这条表达式就可能被视<br />
为：<br />
int d=E*12+a+（a+E）；<br />
这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一<br />
种优化：代数化简（Algebraic Simplification），把表达式变为：<br />
int d=E*13+a*2；<br />
表达式进行变换之后，再计算起来就可以节省一些时间了。 如果读者还对其他的经典编<br />
译优化技术感兴趣，可以参考《 编译原理》 （俗称&ldquo;龙书&rdquo;，推荐使用Java的程序员阅读2006<br />
年版的&ldquo;紫龙书&rdquo;）中的相关章节。<br />
11.3.3 数组边界检查消除<br />
数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相<br />
关的经典优化技术。 我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像<br />
C、 C++那样在本质上是裸指针操作。 如果有一个数组foo[]，在Java语言中访问数组元素<br />
foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i＞=0＆＆i＜foo.length这<br />
个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。 这对软件<br />
开发者来说是一件很好的事情，即使程序员没有专门编写防御代码，也可以避免大部分的溢<br />
出攻击。 但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判<br />
定操作，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。<br />
无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查是不是必须在运<br />
行期间一次不漏地检查则是可以&ldquo;商量&rdquo;的事情。 例如下面这个简单的情况：数组下标是一个<br />
常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标&ldquo;3&rdquo;没有越<br />
界，执行的时候就无须判断了。 更加常见的情况是数组访问发生在循环之中，并且使用循环<br />
变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远<br />
在区间[0，foo.length）之内，那在整个循环中就可以把数组的上下界检查消除，这可以节省<br />
很多次的条件判断操作。<br />
将这个数组边界检查的例子放在更高的角度来看，大量的安全检查令编写Java程序比编<br />
写C/C++程序容易很多，如数组越界会得到ArrayIndexOutOfBoundsException异常，空指针访<br />
问会得到NullPointException，除数为零会得到ArithmeticException等，在C/C++程序中出现类<br />
似的问题，一不小心就会出现Segment Fault信号或者Window编程中常见的&ldquo;xxx内存不能为<br />
Read/Write&rdquo;之类的提示，处理不好程序就直接崩溃退出了。 但这些安全检查也导致了相同的<br />
程序，Java要比C/C++做更多的事情（各种检查判断），这些事情就成为一种隐式开销，如<br />
果处理不好它们，就很可能成为一个Java语言比C/C++更慢的因素。 要消除这些隐式开销，<br />
除了如数组边界检查优化这种尽可能把运行期检查提到编译期完成的思路之外，另外还有一<br />
种避免思路&mdash;&mdash;隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这<br />
种思路。 举个例子，例如程序中访问一个对象（假设对象叫foo）的某个属性（假设属性叫<br />
value），那以Java伪代码来表示虚拟机访问foo.value的过程如下。<br />
if（foo！=null）{<br />
return foo.value；<br />
}else{<br />
throw new NullPointException（）；<br />
} 在<br />
使用隐式异常优化之后，虚拟机会把上面伪代码所表示的访问过程变为如下伪代码。<br />
try{<br />
return foo.value；<br />
}catch（segment_fault）{<br />
uncommon_trap（）；<br />
} 虚<br />
拟机会注册一个Segment Fault信号的异常处理器（伪代码中的uncommon_trap（）），<br />
这样当foo不为空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。 代价就是<br />
当foo真的为空时，必须转入到异常处理器中恢复并抛出NullPointException异常，这个过程必<br />
须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢。 当foo极<br />
少为空的时候，隐式异常优化是值得的，但假如foo经常为空的话，这样的优化反而会让程<br />
序更慢，还好HotSpot虚拟机足够&ldquo;聪明&rdquo;，它会根据运行期收集到的Profile信息自动选择最优<br />
方案。<br />
与语言相关的其他消除操作还有不少，如自动装箱消除（Autobox Elimination）、 安全点<br />
消除（Safepoint Elimination）、 消除反射（Dereflection）等，笔者就不再一一介绍了。<br />
11.3.4 方法内联<br />
在前面的讲解之中我们提到过方法内联，它是编译器最重要的优化手段之一，除了消除<br />
方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础，如代码清单11-<br />
12所示的简单例子就揭示了内联对其他优化手段的意义：事实上testInline（）方法的内部全<br />
部都是无用的代码，如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任<br />
何&ldquo;Dead Code&rdquo;，因为如果分开来看，foo（）和testInline（）两个方法里面的操作都可能是<br />
有意义的。<br />
代码清单11-12 未做任何优化的字节码<br />
public static void foo（Object obj）{<br />
if（obj！=null）{<br />
System.out.println（&quot;do something&quot;）；<br />
}}p<br />
ublic static void testInline（String[]args）{<br />
Object obj=null；<br />
foo（obj）；<br />
} 方<br />
法内联的优化行为看起来很简单，不过是把目标方法的代码&ldquo;复制&rdquo;到发起调用的方法<br />
之中，避免发生真实的方法调用而已。 但实际上Java虚拟机中的内联过程远远没有那么简<br />
单，因为如果不是即时编译器做了一些特别的努力，按照经典编译原理的优化理论，大多数<br />
的Java方法都无法进行内联。<br />
无法内联的原因其实在第8章中讲解Java方法解析和分派调用的时候就已经介绍过。 只<br />
有使用invokespecial指令调用的私有方法、 实例构造器、 父类方法以及使用invokestatic指令<br />
进行调用的静态方法才是在编译期进行解析的，除了上述4种方法之外，其他的Java方法调<br />
用都需要在运行时进行方法接收者的多态选择，并且都有可能存在多于一个版本的方法接收<br />
者（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是<br />
非虚方法，Java语言规范中明确说明了这点），简而言之，Java语言中默认的实例方法是虚<br />
方法。<br />
对于一个虚方法，编译期做内联的时候根本无法确定应该使用哪个方法版本，如果以代<br />
码清单11-7中把&ldquo;b.get（）&rdquo;内联为&ldquo;b.value&rdquo;为例的话，就是不依赖上下文就无法确定b的实际<br />
类型是什么。 假如有ParentB和SubB两个具有继承关系的类，并且子类重写了父类的get（）<br />
方法，那么，是要执行父类的get（）方法还是子类的get（）方法，需要在运行期才能确<br />
定，编译期无法得出结论。<br />
由于Java语言提倡使用面向对象的编程方式进行编程，而Java对象的方法默认就是虚方<br />
法，因此Java间接鼓励了程序员使用大量的虚方法来完成程序逻辑。 根据上面的分析，如果<br />
内联与虚方法之间产生&ldquo;矛盾&rdquo;，那该怎么办呢？是不是为了提高执行性能，就要到处使用<br />
final关键字去修饰方法呢？<br />
为了解决虚方法的内联问题，Java虚拟机设计团队想了很多办法，首先是引入了一种名<br />
为&ldquo;类型继承关系分析&rdquo;（Class Hierarchy Analysis,CHA）的技术，这是一种基于整个应用程<br />
序的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某<br />
个类是否存在子类、 子类是否为抽象类等信息。<br />
编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了，这时候的内联是<br />
有稳定前提保障的。 如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标<br />
版本可供选择，如果查询结果只有一个版本，那也可以进行内联，不过这种内联就属于激进<br />
优化，需要预留一个&ldquo;逃生门&rdquo;（Guard条件不成立时的Slow Path），称为守护内联（Guarded<br />
Inlining）。 如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继<br />
承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。 但如果加载了导致继承<br />
关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行<br />
编译。<br />
如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会进行最<br />
后一次努力，使用内联缓存（Inline Cache）来完成方法内联，这是一个建立在目标方法正常<br />
入口之前的缓存，它的工作原理大致是：在未发生方法调用之前，内联缓存状态为空，当第<br />
一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收<br />
者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用<br />
下去。 如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这<br />
时才会取消内联，查找虚方法表进行方法分派。<br />
所以说，在许多情况下虚拟机进行的内联都是一种激进优化，激进优化的手段在高性能<br />
的商用虚拟机中很常见，除了内联之外，对于出现概率很小（通过经验数据或解释器收集到<br />
的性能监控信息确定概率大小）的隐式异常、 使用概率很小的分支等都可以被激进优化&ldquo;移<br />
除&rdquo;，如果真的出现了小概率事件，这时才会从&ldquo;逃生门&rdquo;回到解释状态重新执行。<br />
11.3.5 逃逸分析<br />
逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承<br />
关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。<br />
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能<br />
被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。 甚至还有可能被<br />
外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。<br />
如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何<br />
途径访问到这个对象，则可能为这个变量进行一些高效的优化，如下所示。<br />
栈上分配（Stack Allocation）：Java虚拟机中，在Java堆上分配创建对象的内存空间几乎<br />
是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有<br />
这个对象的引用，就可以访问堆中存储的对象数据。 虚拟机的垃圾收集系统可以回收堆中不<br />
再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。<br />
如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的<br />
主意，对象所占用的内存空间就可以随栈帧出栈而销毁。 在一般应用中，不会逃逸的局部对<br />
象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁<br />
了，垃圾收集系统的压力将会小很多。<br />
同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，如果逃<br />
逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就<br />
不会有竞争，对这个变量实施的同步措施也就可以消除掉。<br />
标量替换（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小<br />
的数据来表示了，Java虚拟机中的原始数据类型（int、 long等数值类型以及reference类型等）<br />
都不能再进一步分解，它们就可以称为标量。 相对的，如果一个数据可以继续分解，那它就<br />
称作聚合量（Aggregate），Java中的对象就是最典型的聚合量。 如果把一个Java对象拆散，<br />
根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。 如果逃<br />
逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时<br />
候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代<br />
替。 将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会<br />
被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优<br />
化手段创建条件。<br />
关于逃逸分析的论文在1999年就已经发表，但直到Sun JDK 1.6才实现了逃逸分析，而且<br />
直到现在这项优化尚未足够成熟，仍有很大的改进余地。 不成熟的原因主要是不能保证逃逸<br />
分析的性能收益必定高于它的消耗。 如果要完全准确地判断一个对象是否会逃逸，需要进行<br />
数据流敏感的一系列复杂分析，从而确定程序各个分支执行时对此对象的影响。 这是一个相<br />
对高耗时的过程，如果分析完后发现没有几个不逃逸的对象，那这些运行期耗用的时间就白<br />
白浪费了，所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成逃逸分<br />
析。 还有一点是，基于逃逸分析的一些优化手段，如上面提到的&ldquo;栈上分配&rdquo;，由于HotSpot虚<br />
拟机目前的实现方式导致栈上分配实现起来比较复杂，因此在HotSpot中暂时还没有做这项<br />
优化。<br />
在测试结果中，实施逃逸分析后的程序在MicroBenchmarks中往往能运行出不错的成<br />
绩，但是在实际的应用程序，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定<br />
的情况，或因分析过程耗时但却无法有效判别出非逃逸对象而导致性能（即时编译的收益）<br />
有所下降，所以在很长的一段时间里，即使是Server Compiler，也默认不开启逃逸分析[1]，甚<br />
至在某些版本（如JDK 1.6 Update 18）中还曾经短暂地完全禁止了这项优化。<br />
如果有需要，并且确认对程序运行有益，用户可以使用参数-XX：+DoEscapeAnalysis来<br />
手动开启逃逸分析，开启之后可以通过参数-XX：+PrintEscapeAnalysis来查看分析结果。 有<br />
了逃逸分析支持之后，用户可以使用参数-XX：+EliminateAllocations来开启标量替换，使用<br />
+XX：+EliminateLocks来开启同步消除，使用参数-XX：+PrintEliminateAllocations查看标量<br />
的替换情况。<br />
尽管目前逃逸分析的技术仍不是十分成熟，但是它却是即时编译器优化技术的一个重要<br />
的发展方向，在今后的虚拟机中，逃逸分析技术肯定会支撑起一系列实用有效的优化技术。<br />
[1]在JDK 1.6 Update 23的Server Compiler中才开始默认开启了逃逸分析。<br />
11.4 Java与C/C++的编译器对比<br />
大多数程序员都认为C/C++会比Java语言快，甚至觉得从Java语言诞生以来&ldquo;执行速度缓<br />
慢&rdquo;的帽子就应当扣在它的头顶，这种观点的出现是由于Java刚出现的时候即时编译技术还<br />
不成熟，主要靠解释器执行的Java语言性能确实比较低下。 但目前即时编译技术已经十分成<br />
熟，Java语言有可能在速度上与C/C++一争高下吗？要想知道这个问题的答案，让我们从两<br />
者的编译器谈起[1]。<br />
Java与C/C++的编译器对比实际上代表了最经典的即时编译器与静态编译器的对比，很<br />
大程度上也决定了Java与C/C++的性能对比的结果，因为无论是C/C++还是Java代码，最终编<br />
译之后被机器执行的都是本地机器码，哪种语言的性能更高，除了它们自身的API库实现得<br />
好坏以外，其余的比较就成了一场&ldquo;拼编译器&rdquo;和&ldquo;拼输出代码质量&rdquo;的游戏。 当然，这种比较<br />
也是剔除了开发效率的片面对比，语言间孰优孰劣、 谁快谁慢的问题都是很难有结果的争<br />
论，下面我们就回到正题，看看这两种语言的编译器各有何种优势。<br />
Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因而<br />
导致输出的本地代码有一些劣势（下面列举的也包括一些虚拟机执行子系统的性能劣势）：<br />
第一，因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能<br />
提供的优化手段也严重受制于编译成本。 如果编译速度不能达到要求，那用户将在启动程序<br />
或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而<br />
编译的时间成本在静态优化编译器中并不是主要的关注点。<br />
第二，Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反<br />
语言语义或访问非结构化内存。 从实现层面上看，这就意味着虚拟机必须频繁地进行动态检<br />
查，如实例方法访问时检查空指针、 数组元素访问时检查上下界范围、 类型转换时检查继承<br />
关系等。 对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总<br />
体上仍然要消耗不少的运行时间。<br />
第三，Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语<br />
言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即<br />
时编译器在进行一些优化（如前面提到的方法内联）时的难度要远大于C/C++的静态优化编<br />
译器。<br />
第四，Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关<br />
系，这使得很多全局的优化都难以进行，因为编译器无法看见程序的全貌，许多全局的优化<br />
措施都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时<br />
撤销或重新进行一些优化。<br />
第五，Java语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上<br />
分配[2]。 而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如<br />
果可以在栈上分配线程私有的对象，将减轻内存回收的压力。 另外，C/C++中主要由用户程<br />
序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅指运行效率，<br />
排除了开发效率）也比垃圾收集机制要高。<br />
上面说了一大堆Java语言相对C/C++的劣势，不是说Java就真的不如C/C++了，相信读者<br />
也注意到了，Java语言的这些性能上的劣势都是为了换取开发效率上的优势而付出的代价，<br />
动态安全、 动态扩展、 垃圾回收这些&ldquo;拖后腿&rdquo;的特性都为Java语言的开发效率做出了很大贡<br />
献。<br />
何况，还有许多优化是Java的即时编译器能做而C/C++的静态优化编译器不能做或者不<br />
好做的。 例如，在C/C++中，别名分析（Alias Analysis）的难度就要远高于Java。 Java的类型<br />
安全保证了在类似如下代码中，只要ClassA和ClassB没有继承关系，那对象objA和objB就绝<br />
不可能是同一个对象，即不会是同一块内存两个不同别名。<br />
void foo（ClassA objA,ClassB objB）{<br />
objA.x=123；<br />
objB.y=456；<br />
//只要objB.y不是objA.x的别名，下面就可以保证输出为123<br />
print（objA.x）；<br />
} 确<br />
定了objA和objB并非对方的别名后，许多与数据依赖相关的优化才可以进行（重排<br />
序、 变量代换）。 具体到这个例子中，就是无须担心objB.y其实与objA.x指向同一块内存，<br />
这样就可以安全地确定打印语句中的objA.x为123。<br />
Java编译器另外一个红利是由它的动态性所带来的，由于C/C++编译器所有优化都在编<br />
译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测（Call<br />
Frequency Prediction）、 分支频率预测（Branch Frequency Prediction）、 裁剪未被选择的分支<br />
（Untaken Branch Pruning）等，这些都会成为Java语言独有的性能优势。<br />
[1]C/C++与Java孰优孰劣、 谁快谁慢这类话题已经争论了十几年，双方的支持者从来都没有<br />
说服过对方，有朋友好意提醒过笔者不要跳入这种语言性能争论的&ldquo;火坑&rdquo;，把这节移除掉。<br />
笔者在此也特别说明，本节的目的仅是从编译和执行的角度来探讨两者的差异，并不是去评<br />
判孰优孰劣。<br />
[2]Java中非逃逸对象的标量替换优化可以看做是一种高度优化后的栈上分配，但它相当于把<br />
对象拆散成局部变量再进行的栈上分配，而不是C/C++那种程序代码可控的栈上分配方式。<br />
11.5 本章小结<br />
第10～11两章分别介绍了Java程序从源码编译成字节码和从字节码编译成本地机器码的<br />
过程，Javac字节码编译器与虚拟机内的JIT编译器的执行过程合并起来其实就等同于一个传<br />
统编译器所执行的编译过程。<br />
本章中，我们着重了解了虚拟机的热点探测方法、 HotSpot的即时编译器、 编译触发条<br />
件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果，还选择了几种常见的编译期<br />
优化技术进行讲解。 对Java编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以<br />
帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。<br />
&nbsp;</p>
