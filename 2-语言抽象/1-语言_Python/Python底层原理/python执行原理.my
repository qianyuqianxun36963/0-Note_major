<h1>Python解释执行原理</h1>

<p>&nbsp;&nbsp;这里的解释执行是相对于编译执行而言的。我们都知道，使用C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。运行该程序的时候，就可以把二进制程序从硬盘载入到内存中并运行。</p>

<p>&nbsp;&nbsp;但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。当我们运行python文件程序的时候，<strong>python解释器</strong>将源代码转换为字节码，然后再由<strong>python解释器</strong>来执行这些字节码。这样，python就不用担心程序的编译,库的链接加载等问题了。</p>

<h2>对于python解释语言，有以下3方面的特性：</h2>

<ol>
	<li>每次运行都要进行转换成字节码，然后再有虚拟机把字节码转换成机器语言，最后才能在硬件上运行。与编译性语言相比，每次多出了编译和链接的过程，性能肯定会受到影响。</li>
	<li>由于不用关心程序的编译和库的链接等问题，开发的工作也就更加轻松啦。</li>
	<li>python代码与机器底层更远了，python程序更加易于移植，基本上无需改动就能在多平台上运行。</li>
</ol>

<h2>编译型语言和解释型语言</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在具体计算机上实现一种语言，首先要确定的是表示该语言语义解释的虚拟计算机，一个关键的问题是程序执行时的基本表示是<strong>实际计算机上的机器语言还是虚拟机的机器语言</strong>。这个问题决定了语言的实现。根据这个问题的回答，可以将程序设计语言划分为两大类：<strong>编译型语言和解释型语言</strong>。</p>

<ol>
	<li><strong>编译实现的语言</strong>，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过编译,汇编和链接才能输出目标代码，然后由机器执行目标代码。目标代码是有机器指令组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。</li>
	<li><strong>解释型语言</strong>，解释器不产生目标机器代码，而是产生中间代码，这种中间代码与机器代码不同，中间代码的解释是由软件支持的，不能直接使用在硬件上。该软件解释器通常会导致执行效率较低，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是, 解释程序的任务是逐一将源代码的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个专门的解释器来执行该程序，每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。</li>
	<li><strong>Java解释器</strong>，java很特殊，java是需要编译的，但是没有直接编译成机器语言，而是编译成字节码，然后在Java虚拟机上用解释的方式执行字节码。Python也使用了类似的方式，先将python编译成python字节码，然后由一个专门的python字节码解释器负责解释执行字节码。</li>
	<li><strong>python是一门解释语言</strong>，但是出于效率的考虑，提供了一种编译的方法。编译之后就得到pyc文件，存储了字节码。python这点和java很类似，但是<strong>java与python不同的是，python是一个解释型的语言，所以编译字节码不是一个强制的操作</strong>，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以节省加载模块的时间，提高效率。</li>
	<li><strong>除了效率之外</strong>，字节码的形式也增加了反向工程的难度，可以保护源代码。这个只是一定程度上的保护，反编译还是可以的。</li>
</ol>
